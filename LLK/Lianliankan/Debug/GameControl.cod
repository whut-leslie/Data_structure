; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\Study\数据结构与算法综合实验\连连看游戏\LLKPro17.6.18\Lianliankan\GameControl.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?s_nRows@CGameControl@@2HA			; CGameControl::s_nRows
PUBLIC	?s_nCols@CGameControl@@2HA			; CGameControl::s_nCols
PUBLIC	?s_nPicNum@CGameControl@@2HA			; CGameControl::s_nPicNum
_DATA	SEGMENT
?s_nRows@CGameControl@@2HA DD 0aH			; CGameControl::s_nRows
?s_nCols@CGameControl@@2HA DD 010H			; CGameControl::s_nCols
?s_nPicNum@CGameControl@@2HA DD 014H			; CGameControl::s_nPicNum
_DATA	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0CGameControl@@QAE@XZ				; CGameControl::CGameControl
PUBLIC	??1CGameControl@@QAE@XZ				; CGameControl::~CGameControl
PUBLIC	?StartGame@CGameControl@@QAEXXZ			; CGameControl::StartGame
PUBLIC	?GetElement@CGameControl@@QAEHHH@Z		; CGameControl::GetElement
PUBLIC	?Rerank@CGameControl@@QAEXXZ			; CGameControl::Rerank
PUBLIC	?SetFirstPoint@CGameControl@@QAEXHH@Z		; CGameControl::SetFirstPoint
PUBLIC	?SetSecPoint@CGameControl@@QAEXHH@Z		; CGameControl::SetSecPoint
PUBLIC	?Link@CGameControl@@QAE_NPAUtagVertex@@AAH@Z	; CGameControl::Link
PUBLIC	?SearchValidPath@CGameControl@@QAE_NPAUtagVertex@@AAH@Z ; CGameControl::SearchValidPath
PUBLIC	?Help@CGameControl@@QAE_NPAUtagVertex@@AAH@Z	; CGameControl::Help
PUBLIC	?IsWin@CGameControl@@QAE_NXZ			; CGameControl::IsWin
EXTRN	??0CGameLogic@@QAE@XZ:PROC			; CGameLogic::CGameLogic
EXTRN	??1CGameLogic@@QAE@XZ:PROC			; CGameLogic::~CGameLogic
EXTRN	?InitMap@CGameLogic@@QAEPAPAHXZ:PROC		; CGameLogic::InitMap
EXTRN	?ReleaseMap@CGameLogic@@QAEXAAPAPAH@Z:PROC	; CGameLogic::ReleaseMap
EXTRN	?RerankGraph@CGameLogic@@QAEXPAPAH@Z:PROC	; CGameLogic::RerankGraph
EXTRN	?IsLink@CGameLogic@@QAE_NPAPAHUtagVertex@@1@Z:PROC ; CGameLogic::IsLink
EXTRN	?Clear@CGameLogic@@QAEXPAPAHUtagVertex@@1@Z:PROC ; CGameLogic::Clear
EXTRN	?GetVexPath@CGameLogic@@QAEHQAUtagVertex@@@Z:PROC ; CGameLogic::GetVexPath
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGameControl@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?IsWin@CGameControl@@QAE_NXZ
_TEXT	SEGMENT
?IsWin@CGameControl@@QAE_NXZ PROC			; CGameControl::IsWin, COMDAT
; _this$ = ecx

; 129  : 	/*如果消除的图片数与原有图片数相等，则判定玩家取胜；优化了每次遍历二维地图数组带来的时空复杂度*/
; 130  : 	if (clearPic == s_nRows*s_nCols)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_nCols@CGameControl@@2HA ; CGameControl::s_nCols
  00005	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?s_nRows@CGameControl@@2HA ; CGameControl::s_nRows
  0000c	39 41 38	 cmp	 DWORD PTR [ecx+56], eax
  0000f	75 0a		 jne	 SHORT $LN2@IsWin

; 131  : 	{
; 132  : 		clearPic = 0;   //重置计数器，为下一轮做准备

  00011	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 133  : 		return true;

  00018	b0 01		 mov	 al, 1

; 137  : }

  0001a	c3		 ret	 0
$LN2@IsWin:

; 134  : 	}
; 135  : 	else
; 136  : 		return false;

  0001b	32 c0		 xor	 al, al

; 137  : }

  0001d	c3		 ret	 0
?IsWin@CGameControl@@QAE_NXZ ENDP			; CGameControl::IsWin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?Help@CGameControl@@QAE_NPAUtagVertex@@AAH@Z
_TEXT	SEGMENT
tv310 = -16						; size = 4
_y1$1$ = -12						; size = 4
_x2$1$ = -8						; size = 4
_x1$1$ = -4						; size = 4
_avPath$ = 8						; size = 4
_nVexnum$ = 12						; size = 4
?Help@CGameControl@@QAE_NPAUtagVertex@@AAH@Z PROC	; CGameControl::Help, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx

; 103  : 	int x1, y1, x2, y2;
; 104  : 	for(x1 = 0; x1 < s_nRows; x1++)

  0000b	33 f6		 xor	 esi, esi
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_nRows@CGameControl@@2HA ; CGameControl::s_nRows
  00013	89 75 fc	 mov	 DWORD PTR _x1$1$[ebp], esi
  00016	85 c9		 test	 ecx, ecx
  00018	0f 8e 05 01 00
	00		 jle	 $LN3@Help
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_nCols@CGameControl@@2HA ; CGameControl::s_nCols
$LL4@Help:

; 105  : 		for (y1 = 0; y1 < s_nCols; y1++)

  00024	33 db		 xor	 ebx, ebx
  00026	89 5d f4	 mov	 DWORD PTR _y1$1$[ebp], ebx
  00029	85 d2		 test	 edx, edx
  0002b	0f 8e e6 00 00
	00		 jle	 $LN2@Help
$LL7@Help:

; 103  : 	int x1, y1, x2, y2;
; 104  : 	for(x1 = 0; x1 < s_nRows; x1++)

  00031	8b 07		 mov	 eax, DWORD PTR [edi]
  00033	8d 34 b0	 lea	 esi, DWORD PTR [eax+esi*4]

; 106  : 		{
; 107  : 			if (m_pGameMap[x1][y1] != BLANK)

  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	83 3c 98 ff	 cmp	 DWORD PTR [eax+ebx*4], -1
  0003c	0f 84 c6 00 00
	00		 je	 $LN47@Help

; 48   : 	m_svSelFst.row = nRow;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _x1$1$[ebp]
  00045	89 47 3c	 mov	 DWORD PTR [edi+60], eax

; 49   : 	m_svSelFst.col = nCol;

  00048	89 5f 40	 mov	 DWORD PTR [edi+64], ebx

; 50   : 	m_svSelFst.info = m_pGameMap[nRow][nCol];

  0004b	8b 06		 mov	 eax, DWORD PTR [esi]

; 108  : 			{
; 109  : 				SetFirstPoint(x1, y1);			  //设置第一个点
; 110  : 				for (x2 = x1; x2 < s_nRows; x2++)   //继续遍历剩余地图元素，寻找第二个点

  0004d	8b 75 fc	 mov	 esi, DWORD PTR _x1$1$[ebp]

; 50   : 	m_svSelFst.info = m_pGameMap[nRow][nCol];

  00050	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  00053	89 47 44	 mov	 DWORD PTR [edi+68], eax

; 108  : 			{
; 109  : 				SetFirstPoint(x1, y1);			  //设置第一个点
; 110  : 				for (x2 = x1; x2 < s_nRows; x2++)   //继续遍历剩余地图元素，寻找第二个点

  00056	8b c6		 mov	 eax, esi
  00058	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_nRows@CGameControl@@2HA ; CGameControl::s_nRows
  0005e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_nCols@CGameControl@@2HA ; CGameControl::s_nCols
  00064	89 45 f8	 mov	 DWORD PTR _x2$1$[ebp], eax
  00067	3b f1		 cmp	 esi, ecx
  00069	0f 8d 9c 00 00
	00		 jge	 $LN5@Help
  0006f	90		 npad	 1
$LL10@Help:

; 111  : 					for (y2 = y1+1; y2 < s_nCols; y2++)

  00070	8d 73 01	 lea	 esi, DWORD PTR [ebx+1]
  00073	3b f2		 cmp	 esi, edx
  00075	0f 8d 81 00 00
	00		 jge	 $LN8@Help
  0007b	0f 1f 44 00 00	 npad	 5
$LL13@Help:

; 112  : 					{
; 113  : 						if (m_pGameMap[x2][y2] == m_pGameMap[x1][y1])  //如果两个点的图片相同

  00080	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _x1$1$[ebp]
  00085	8b 55 f4	 mov	 edx, DWORD PTR _y1$1$[ebp]
  00088	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  0008b	8b 0c 8b	 mov	 ecx, DWORD PTR [ebx+ecx*4]
  0008e	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00091	3b 04 91	 cmp	 eax, DWORD PTR [ecx+edx*4]
  00094	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_nCols@CGameControl@@2HA ; CGameControl::s_nCols
  0009a	75 4f		 jne	 SHORT $LN11@Help

; 56   : 	m_svSelSec.row = nRow;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _x2$1$[ebp]

; 92   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  0009f	8d 57 04	 lea	 edx, DWORD PTR [edi+4]

; 56   : 	m_svSelSec.row = nRow;

  000a2	89 47 48	 mov	 DWORD PTR [edi+72], eax

; 92   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  000a5	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 57   : 	m_svSelSec.col = nCol;

  000a8	89 77 4c	 mov	 DWORD PTR [edi+76], esi

; 92   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  000ab	8b cc		 mov	 ecx, esp
  000ad	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b0	89 55 f0	 mov	 DWORD PTR tv310[ebp], edx

; 58   : 	m_svSelSec.info = m_pGameMap[nRow][nCol];

  000b3	8b 04 83	 mov	 eax, DWORD PTR [ebx+eax*4]
  000b6	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  000b9	89 47 50	 mov	 DWORD PTR [edi+80], eax

; 92   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  000bc	c5 fa 7e 47 48	 vmovq	 xmm0, QWORD PTR [edi+72]
  000c1	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  000c5	c5 fa 7e 47 3c	 vmovq	 xmm0, QWORD PTR [edi+60]
  000ca	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000cd	8b cc		 mov	 ecx, esp
  000cf	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  000d2	53		 push	 ebx
  000d3	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  000d7	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000da	8b ca		 mov	 ecx, edx
  000dc	e8 00 00 00 00	 call	 ?IsLink@CGameLogic@@QAE_NPAPAHUtagVertex@@1@Z ; CGameLogic::IsLink
  000e1	84 c0		 test	 al, al
  000e3	75 49		 jne	 SHORT $LN42@Help
  000e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_nCols@CGameControl@@2HA ; CGameControl::s_nCols
$LN11@Help:

; 111  : 					for (y2 = y1+1; y2 < s_nCols; y2++)

  000eb	8b 45 f8	 mov	 eax, DWORD PTR _x2$1$[ebp]
  000ee	46		 inc	 esi
  000ef	3b f2		 cmp	 esi, edx
  000f1	7c 8d		 jl	 SHORT $LL13@Help
  000f3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?s_nRows@CGameControl@@2HA ; CGameControl::s_nRows
  000f9	8b 5d f4	 mov	 ebx, DWORD PTR _y1$1$[ebp]
$LN8@Help:

; 108  : 			{
; 109  : 				SetFirstPoint(x1, y1);			  //设置第一个点
; 110  : 				for (x2 = x1; x2 < s_nRows; x2++)   //继续遍历剩余地图元素，寻找第二个点

  000fc	40		 inc	 eax
  000fd	89 45 f8	 mov	 DWORD PTR _x2$1$[ebp], eax
  00100	3b c1		 cmp	 eax, ecx
  00102	0f 8c 68 ff ff
	ff		 jl	 $LL10@Help
$LN47@Help:
  00108	8b 75 fc	 mov	 esi, DWORD PTR _x1$1$[ebp]
$LN5@Help:

; 105  : 		for (y1 = 0; y1 < s_nCols; y1++)

  0010b	43		 inc	 ebx
  0010c	89 5d f4	 mov	 DWORD PTR _y1$1$[ebp], ebx
  0010f	3b da		 cmp	 ebx, edx
  00111	0f 8c 1a ff ff
	ff		 jl	 $LL7@Help
$LN2@Help:

; 103  : 	int x1, y1, x2, y2;
; 104  : 	for(x1 = 0; x1 < s_nRows; x1++)

  00117	46		 inc	 esi
  00118	89 75 fc	 mov	 DWORD PTR _x1$1$[ebp], esi
  0011b	3b f1		 cmp	 esi, ecx
  0011d	0f 8c 01 ff ff
	ff		 jl	 $LL4@Help
$LN3@Help:

; 118  : 						}
; 119  : 					}
; 120  : 			}
; 121  : 		}
; 122  : 
; 123  : 	return false;   //循环完成后还没找到可以消除的图片则返回false，由上一级做出判决

  00123	32 c0		 xor	 al, al

; 124  : }

  00125	5f		 pop	 edi
  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 08 00	 ret	 8
$LN42@Help:

; 94   : 		nVexnum = m_GameLogic.GetVexPath(avPath);	 // 返回路径顶点数  

  0012e	ff 75 08	 push	 DWORD PTR _avPath$[ebp]
  00131	8b 4d f0	 mov	 ecx, DWORD PTR tv310[ebp]
  00134	e8 00 00 00 00	 call	 ?GetVexPath@CGameLogic@@QAEHQAUtagVertex@@@Z ; CGameLogic::GetVexPath
  00139	8b 4d 0c	 mov	 ecx, DWORD PTR _nVexnum$[ebp]

; 124  : }

  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx

; 94   : 		nVexnum = m_GameLogic.GetVexPath(avPath);	 // 返回路径顶点数  

  0013f	89 01		 mov	 DWORD PTR [ecx], eax

; 114  : 						{
; 115  : 							SetSecPoint(x2, y2);        //设置第二个点
; 116  : 							if (SearchValidPath(avPath, nVexnum))   //如果可以连通
; 117  : 								return true;

  00141	b0 01		 mov	 al, 1

; 124  : }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c2 08 00	 ret	 8
?Help@CGameControl@@QAE_NPAUtagVertex@@AAH@Z ENDP	; CGameControl::Help
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?SearchValidPath@CGameControl@@QAE_NPAUtagVertex@@AAH@Z
_TEXT	SEGMENT
_avPath$ = 8						; size = 4
_nVexnum$ = 12						; size = 4
?SearchValidPath@CGameControl@@QAE_NPAUtagVertex@@AAH@Z PROC ; CGameControl::SearchValidPath, COMDAT
; _this$ = ecx

; 90   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 91   : 	// 判断是否连通 
; 92   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  00007	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000a	8b d4		 mov	 edx, esp
  0000c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000f	c5 fa 7e 46 48	 vmovq	 xmm0, QWORD PTR [esi+72]
  00014	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  00017	8b cc		 mov	 ecx, esp
  00019	ff 36		 push	 DWORD PTR [esi]
  0001b	c5 f9 d6 02	 vmovq	 QWORD PTR [edx], xmm0
  0001f	c5 fa 7e 46 3c	 vmovq	 xmm0, QWORD PTR [esi+60]
  00024	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00027	8b 46 44	 mov	 eax, DWORD PTR [esi+68]
  0002a	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  0002e	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00031	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00034	e8 00 00 00 00	 call	 ?IsLink@CGameLogic@@QAE_NPAPAHUtagVertex@@1@Z ; CGameLogic::IsLink
  00039	84 c0		 test	 al, al
  0003b	74 18		 je	 SHORT $LN2@SearchVali

; 93   : 	{
; 94   : 		nVexnum = m_GameLogic.GetVexPath(avPath);	 // 返回路径顶点数  

  0003d	ff 75 08	 push	 DWORD PTR _avPath$[ebp]
  00040	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00043	e8 00 00 00 00	 call	 ?GetVexPath@CGameLogic@@QAEHQAUtagVertex@@@Z ; CGameLogic::GetVexPath
  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _nVexnum$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 95   : 		return true;

  0004d	b0 01		 mov	 al, 1

; 96   : 	}
; 97   : 	return false;
; 98   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5d		 pop	 ebp
  00052	c2 08 00	 ret	 8
$LN2@SearchVali:
  00055	5f		 pop	 edi
  00056	32 c0		 xor	 al, al
  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?SearchValidPath@CGameControl@@QAE_NPAUtagVertex@@AAH@Z ENDP ; CGameControl::SearchValidPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?Link@CGameControl@@QAE_NPAUtagVertex@@AAH@Z
_TEXT	SEGMENT
_avPath$ = 8						; size = 4
_nVexnum$ = 12						; size = 4
?Link@CGameControl@@QAE_NPAUtagVertex@@AAH@Z PROC	; CGameControl::Link, COMDAT
; _this$ = ecx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 64   : 	// 判断是否同一张图片  
; 65   : 	if(m_svSelFst.row == m_svSelSec.row && m_svSelFst.col == m_svSelSec.col) 

  00008	8b 5f 3c	 mov	 ebx, DWORD PTR [edi+60]
  0000b	8b 57 48	 mov	 edx, DWORD PTR [edi+72]
  0000e	3b da		 cmp	 ebx, edx
  00010	75 0c		 jne	 SHORT $LN2@Link
  00012	8b 47 40	 mov	 eax, DWORD PTR [edi+64]
  00015	3b 47 4c	 cmp	 eax, DWORD PTR [edi+76]
  00018	0f 84 9f 00 00
	00		 je	 $LN4@Link
$LN2@Link:

; 66   : 	{  
; 67   : 		return false;  
; 68   : 	}  
; 69   : 	// 判断图片是否相同 
; 70   : 	if(m_pGameMap[m_svSelFst.row][m_svSelFst.col]!=m_pGameMap[m_svSelSec.row][m_svSelSec.col])

  0001e	8b 07		 mov	 eax, DWORD PTR [edi]
  00020	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00023	8b 77 4c	 mov	 esi, DWORD PTR [edi+76]
  00026	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00029	8b 04 98	 mov	 eax, DWORD PTR [eax+ebx*4]
  0002c	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0002f	3b 04 b2	 cmp	 eax, DWORD PTR [edx+esi*4]
  00032	0f 85 85 00 00
	00		 jne	 $LN4@Link

; 71   : 	{ 
; 72   : 		return false;  
; 73   : 	}  
; 74   : 
; 75   : 	// 判断是否连通 
; 76   : 	if (m_GameLogic.IsLink(m_pGameMap, m_svSelFst, m_svSelSec))

  00038	c5 fa 7e 47 48	 vmovq	 xmm0, QWORD PTR [edi+72]
  0003d	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00040	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00043	8b cc		 mov	 ecx, esp
  00045	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00048	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  0004c	c5 fa 7e 47 3c	 vmovq	 xmm0, QWORD PTR [edi+60]
  00051	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00054	8b cc		 mov	 ecx, esp
  00056	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00059	ff 37		 push	 DWORD PTR [edi]
  0005b	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  0005f	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00062	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00065	e8 00 00 00 00	 call	 ?IsLink@CGameLogic@@QAE_NPAPAHUtagVertex@@1@Z ; CGameLogic::IsLink
  0006a	84 c0		 test	 al, al
  0006c	74 4f		 je	 SHORT $LN4@Link

; 77   : 	{ 
; 78   : 		// 消子实现 
; 79   : 		m_GameLogic.Clear(m_pGameMap, m_svSelFst, m_svSelSec);

  0006e	c5 fa 7e 47 48	 vmovq	 xmm0, QWORD PTR [edi+72]
  00073	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00076	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00079	8b cc		 mov	 ecx, esp
  0007b	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007e	8b d4		 mov	 edx, esp
  00080	ff 37		 push	 DWORD PTR [edi]
  00082	c5 f9 d6 01	 vmovq	 QWORD PTR [ecx], xmm0
  00086	c5 fa 7e 47 3c	 vmovq	 xmm0, QWORD PTR [edi+60]
  0008b	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0008e	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00091	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00094	c5 f9 d6 02	 vmovq	 QWORD PTR [edx], xmm0
  00098	89 42 08	 mov	 DWORD PTR [edx+8], eax
  0009b	e8 00 00 00 00	 call	 ?Clear@CGameLogic@@QAEXPAPAHUtagVertex@@1@Z ; CGameLogic::Clear

; 80   : 		clearPic += 2;     //以此消除2张图片，计数器加2
; 81   : 		// 返回路径顶点数  
; 82   : 		nVexnum = m_GameLogic.GetVexPath(avPath);

  000a0	ff 75 08	 push	 DWORD PTR _avPath$[ebp]
  000a3	83 47 38 02	 add	 DWORD PTR [edi+56], 2
  000a7	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000aa	e8 00 00 00 00	 call	 ?GetVexPath@CGameLogic@@QAEHQAUtagVertex@@@Z ; CGameLogic::GetVexPath
  000af	8b 4d 0c	 mov	 ecx, DWORD PTR _nVexnum$[ebp]
  000b2	89 01		 mov	 DWORD PTR [ecx], eax

; 83   : 		return true;

  000b4	b0 01		 mov	 al, 1

; 84   : 	}
; 85   : 	return false;
; 86   : }

  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx
  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
$LN4@Link:
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi
  000bf	32 c0		 xor	 al, al
  000c1	5b		 pop	 ebx
  000c2	5d		 pop	 ebp
  000c3	c2 08 00	 ret	 8
?Link@CGameControl@@QAE_NPAUtagVertex@@AAH@Z ENDP	; CGameControl::Link
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?SetSecPoint@CGameControl@@QAEXHH@Z
_TEXT	SEGMENT
_nRow$ = 8						; size = 4
_nCol$ = 12						; size = 4
?SetSecPoint@CGameControl@@QAEXHH@Z PROC		; CGameControl::SetSecPoint, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 56   : 	m_svSelSec.row = nRow;
; 57   : 	m_svSelSec.col = nCol;
; 58   : 	m_svSelSec.info = m_pGameMap[nRow][nCol];

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 0c	 mov	 edx, DWORD PTR _nCol$[ebp]
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _nRow$[ebp]
  0000c	89 71 48	 mov	 DWORD PTR [ecx+72], esi
  0000f	89 51 4c	 mov	 DWORD PTR [ecx+76], edx
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00015	5e		 pop	 esi
  00016	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00019	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 59   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?SetSecPoint@CGameControl@@QAEXHH@Z ENDP		; CGameControl::SetSecPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?SetFirstPoint@CGameControl@@QAEXHH@Z
_TEXT	SEGMENT
_nRow$ = 8						; size = 4
_nCol$ = 12						; size = 4
?SetFirstPoint@CGameControl@@QAEXHH@Z PROC		; CGameControl::SetFirstPoint, COMDAT
; _this$ = ecx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 48   : 	m_svSelFst.row = nRow;
; 49   : 	m_svSelFst.col = nCol;
; 50   : 	m_svSelFst.info = m_pGameMap[nRow][nCol];

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 0c	 mov	 edx, DWORD PTR _nCol$[ebp]
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _nRow$[ebp]
  0000c	89 71 3c	 mov	 DWORD PTR [ecx+60], esi
  0000f	89 51 40	 mov	 DWORD PTR [ecx+64], edx
  00012	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00015	5e		 pop	 esi
  00016	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00019	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 51   : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?SetFirstPoint@CGameControl@@QAEXHH@Z ENDP		; CGameControl::SetFirstPoint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?Rerank@CGameControl@@QAEXXZ
_TEXT	SEGMENT
?Rerank@CGameControl@@QAEXXZ PROC			; CGameControl::Rerank, COMDAT
; _this$ = ecx

; 42   : 	m_GameLogic.RerankGraph(m_pGameMap);    //对地图数组数据重排，并返回地址

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	83 c1 04	 add	 ecx, 4
  00005	e8 00 00 00 00	 call	 ?RerankGraph@CGameLogic@@QAEXPAPAH@Z ; CGameLogic::RerankGraph

; 43   : }

  0000a	c3		 ret	 0
?Rerank@CGameControl@@QAEXXZ ENDP			; CGameControl::Rerank
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?GetElement@CGameControl@@QAEHHH@Z
_TEXT	SEGMENT
_nRow$ = 8						; size = 4
_nCol$ = 12						; size = 4
?GetElement@CGameControl@@QAEHHH@Z PROC			; CGameControl::GetElement, COMDAT
; _this$ = ecx

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   : 	return m_pGameMap[nRow][nCol];   //返回游戏图片号

  00003	8b 45 08	 mov	 eax, DWORD PTR _nRow$[ebp]
  00006	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00008	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  0000b	8b 45 0c	 mov	 eax, DWORD PTR _nCol$[ebp]
  0000e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 37   : }

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?GetElement@CGameControl@@QAEHHH@Z ENDP			; CGameControl::GetElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?StartGame@CGameControl@@QAEXXZ
_TEXT	SEGMENT
?StartGame@CGameControl@@QAEXXZ PROC			; CGameControl::StartGame, COMDAT
; _this$ = ecx

; 29   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 30   : 	m_pGameMap = m_GameLogic.InitMap();    //初始化游戏地图

  00003	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00006	e8 00 00 00 00	 call	 ?InitMap@CGameLogic@@QAEPAPAHXZ ; CGameLogic::InitMap
  0000b	89 06		 mov	 DWORD PTR [esi], eax
  0000d	5e		 pop	 esi

; 31   : 
; 32   : }

  0000e	c3		 ret	 0
?StartGame@CGameControl@@QAEXXZ ENDP			; CGameControl::StartGame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ??1CGameControl@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CGameControl@@QAE@XZ PROC				; CGameControl::~CGameControl, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGameControl@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 23   : 	m_GameLogic.ReleaseMap(m_pGameMap);   //释放游戏地图数组指针

  00023	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00026	51		 push	 ecx
  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?ReleaseMap@CGameLogic@@QAEXAAPAPAH@Z ; CGameLogic::ReleaseMap

; 24   : 	//delete m_pGameMap; 
; 25   : }

  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ??1CGameLogic@@QAE@XZ	; CGameLogic::~CGameLogic
  00035	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00038	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0003f	59		 pop	 ecx
  00040	5e		 pop	 esi
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGameControl@@QAE@XZ:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGameControl@@QAE@XZ
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGameControl@@QAE@XZ ENDP				; CGameControl::~CGameControl
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ??0CGameControl@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CGameControl@@QAE@XZ PROC				; CGameControl::CGameControl, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0000d	e8 00 00 00 00	 call	 ??0CGameLogic@@QAE@XZ	; CGameLogic::CGameLogic

; 18   : 	clearPic = 0;

  00012	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 19   : }

  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0CGameControl@@QAE@XZ ENDP				; CGameControl::CGameControl
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\gamecontrol.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
