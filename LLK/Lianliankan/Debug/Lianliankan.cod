; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	D:\Study\数据结构与算法综合实验\连连看游戏\LLKPro17.6.18\Lianliankan\Lianliankan.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?__LINE__Var@?0???1CLianliankanApp@@UAE@XZ@4JA	; `CLianliankanApp::~CLianliankanApp'::`1'::__LINE__Var
PUBLIC	?__LINE__Var@?0??__autoclassinit2@CLianliankanApp@@QAEXI@Z@4JA ; `CLianliankanApp::__autoclassinit2'::`1'::__LINE__Var
EXTRN	?OnHelp@CWinApp@@IAEXXZ:PROC			; CWinApp::OnHelp
EXTRN	?GetThisMessageMap@CWinApp@@KGPBUAFX_MSGMAP@@XZ:PROC ; CWinApp::GetThisMessageMap
;	COMDAT ?__LINE__Var@?0??__autoclassinit2@CLianliankanApp@@QAEXI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??__autoclassinit2@CLianliankanApp@@QAEXI@Z@4JA DD 028H ; `CLianliankanApp::__autoclassinit2'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ?__LINE__Var@?0???1CLianliankanApp@@UAE@XZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0???1CLianliankanApp@@UAE@XZ@4JA DD 023H	; `CLianliankanApp::~CLianliankanApp'::`1'::__LINE__Var
_DATA	ENDS
CONST	SEGMENT
?_messageEntries@?1??GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B DD 0111H ; `CLianliankanApp::GetThisMessageMap'::`2'::_messageEntries
	DD	00H
	DD	0e146H
	DD	0e146H
	DD	03aH
	DD	FLAT:?OnHelp@CWinApp@@IAEXXZ
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?messageMap@?1??GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ@4U3@B DD FLAT:?GetThisMessageMap@CWinApp@@KGPBUAFX_MSGMAP@@XZ ; `CLianliankanApp::GetThisMessageMap'::`2'::messageMap
	DD	FLAT:?_messageEntries@?1??GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ@4QBUAFX_MSGMAP_ENTRY@@B
?_tlid@@3U_GUID@@B DD 0834e1909H			; _tlid
	DW	06896H
	DW	040edH
	DB	0b3H
	DB	053H
	DB	08eH
	DB	0cfH
	DB	0beH
	DB	06bH
	DB	03eH
	DB	0a8H
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
PUBLIC	_swprintf_s
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z		; ATL::CTrace::TraceV
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?SupportsRestartManager@CWinApp@@UBEHXZ		; CWinApp::SupportsRestartManager
PUBLIC	?SupportsApplicationRecovery@CWinApp@@UBEHXZ	; CWinApp::SupportsApplicationRecovery
PUBLIC	?SupportsAutosaveAtRestart@CWinApp@@UBEHXZ	; CWinApp::SupportsAutosaveAtRestart
PUBLIC	?SupportsAutosaveAtInterval@CWinApp@@UBEHXZ	; CWinApp::SupportsAutosaveAtInterval
PUBLIC	?ReopenPreviousFilesAtRestart@CWinApp@@UBEHXZ	; CWinApp::ReopenPreviousFilesAtRestart
PUBLIC	?RestoreAutosavedFilesAtRestart@CWinApp@@UBEHXZ	; CWinApp::RestoreAutosavedFilesAtRestart
PUBLIC	?GetApplicationRestartFlags@CWinApp@@UAEKXZ	; CWinApp::GetApplicationRestartFlags
PUBLIC	?GetApplicationRecoveryParameter@CWinApp@@UAEPAXXZ ; CWinApp::GetApplicationRecoveryParameter
PUBLIC	?GetApplicationRecoveryPingInterval@CWinApp@@UAEKXZ ; CWinApp::GetApplicationRecoveryPingInterval
PUBLIC	??0CLianliankanApp@@QAE@XZ			; CLianliankanApp::CLianliankanApp
PUBLIC	?InitInstance@CLianliankanApp@@UAEHXZ		; CLianliankanApp::InitInstance
PUBLIC	?ExitInstance@CLianliankanApp@@UAEHXZ		; CLianliankanApp::ExitInstance
PUBLIC	?GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ ; CLianliankanApp::GetThisMessageMap
PUBLIC	?GetMessageMap@CLianliankanApp@@MBEPBUAFX_MSGMAP@@XZ ; CLianliankanApp::GetMessageMap
PUBLIC	??_GCLianliankanApp@@UAEPAXI@Z			; CLianliankanApp::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@ ; `string'
PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
PUBLIC	??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_R1A@?0A@EA@CObject@@8			; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCObject@@@8				; CObject `RTTI Type Descriptor'
PUBLIC	??_R3CObject@@8					; CObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CObject@@8					; CObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCmdTarget@@8			; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCCmdTarget@@@8				; CCmdTarget `RTTI Type Descriptor'
PUBLIC	??_R3CCmdTarget@@8				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCmdTarget@@8				; CCmdTarget::`RTTI Base Class Array'
PUBLIC	??_7CLianliankanApp@@6B@			; CLianliankanApp::`vftable'
PUBLIC	?theApp@@3VCLianliankanApp@@A			; theApp
PUBLIC	?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA ; `CLianliankanApp::InitInstance'::`1'::__LINE__Var
PUBLIC	??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@ ; `string'
PUBLIC	??_C@_1CA@KINOLAIL@?$FO?$JEu?$CIz?$AL?$FO?$IPT?$BB?$FL?$PMu?$BPb?$BAv?$IEg?0W0?$FO?$JEu?$CIz?$AL?$FO?$IP?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CM@BCKBGNML@?$LO?$KP?$LI?f?3?5?$LG?T?$LL?$LA?$LP?r?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM?$KD?$KM?S?$KG?S?C?$LD?L?P?r?$LN?$KL@ ; `string'
PUBLIC	??_C@_0FH@ONNGIDCE@?$LO?$KP?$LI?f?3?5?H?g?$LJ?$PL?D?z?T?Z?$LG?T?$LL?$LA?$LP?r?I?O?J?$LJ?S?C?5MFC?5?$LP@ ; `string'
PUBLIC	??_R4CLianliankanApp@@6B@			; CLianliankanApp::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLianliankanApp@@@8			; CLianliankanApp `RTTI Type Descriptor'
PUBLIC	??_R3CLianliankanApp@@8				; CLianliankanApp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLianliankanApp@@8				; CLianliankanApp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLianliankanApp@@8		; CLianliankanApp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CWinApp@@8			; CWinApp::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWinApp@@@8				; CWinApp `RTTI Type Descriptor'
PUBLIC	??_R3CWinApp@@8					; CWinApp::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWinApp@@8					; CWinApp::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CWinThread@@8			; CWinThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWinThread@@@8				; CWinThread `RTTI Type Descriptor'
PUBLIC	??_R3CWinThread@@8				; CWinThread::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWinThread@@8				; CWinThread::`RTTI Base Class Array'
EXTRN	?__global_delete@@YAXPAXI@Z:PROC		; __global_delete
EXTRN	_atexit:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__InitCommonControlsEx@4:PROC
EXTRN	__imp____stdio_common_vswprintf_s:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp____stdio_common_vsnprintf_s:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	??3CObject@@SGXPAX@Z:PROC			; CObject::operator delete
EXTRN	??2CObject@@SGPAXIPBDH@Z:PROC			; CObject::operator new
EXTRN	??3CObject@@SGXPAXPBDH@Z:PROC			; CObject::operator delete
EXTRN	?Serialize@CObject@@UAEXAAVCArchive@@@Z:PROC	; CObject::Serialize
EXTRN	?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z:PROC ; CCmdTarget::OnCmdMsg
EXTRN	?OnFinalRelease@CCmdTarget@@UAEXXZ:PROC		; CCmdTarget::OnFinalRelease
EXTRN	?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z:PROC	; CCmdTarget::IsInvokeAllowed
EXTRN	?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z:PROC ; CCmdTarget::GetDispatchIID
EXTRN	?GetTypeInfoCount@CCmdTarget@@UAEIXZ:PROC	; CCmdTarget::GetTypeInfoCount
EXTRN	?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ:PROC ; CCmdTarget::GetTypeLibCache
EXTRN	?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z:PROC ; CCmdTarget::GetTypeLib
EXTRN	?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ:PROC ; CCmdTarget::GetCommandMap
EXTRN	?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ:PROC ; CCmdTarget::GetDispatchMap
EXTRN	?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ:PROC ; CCmdTarget::GetConnectionMap
EXTRN	?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ:PROC ; CCmdTarget::GetInterfaceMap
EXTRN	?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ:PROC ; CCmdTarget::GetEventSinkMap
EXTRN	?OnCreateAggregates@CCmdTarget@@UAEHXZ:PROC	; CCmdTarget::OnCreateAggregates
EXTRN	?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z:PROC ; CCmdTarget::GetInterfaceHook
EXTRN	?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z:PROC ; CCmdTarget::GetExtraConnectionPoints
EXTRN	?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z:PROC ; CCmdTarget::GetConnectionHook
EXTRN	?DoModal@CDialog@@UAEHXZ:PROC			; CDialog::DoModal
EXTRN	?PreTranslateMessage@CWinThread@@UAEHPAUtagMSG@@@Z:PROC ; CWinThread::PreTranslateMessage
EXTRN	?PumpMessage@CWinThread@@UAEHXZ:PROC		; CWinThread::PumpMessage
EXTRN	?IsIdleMessage@CWinThread@@UAEHPAUtagMSG@@@Z:PROC ; CWinThread::IsIdleMessage
EXTRN	?ProcessMessageFilter@CWinThread@@UAEHHPAUtagMSG@@@Z:PROC ; CWinThread::ProcessMessageFilter
EXTRN	?GetMainWnd@CWinThread@@UAEPAVCWnd@@XZ:PROC	; CWinThread::GetMainWnd
EXTRN	?Delete@CWinThread@@UAEXXZ:PROC			; CWinThread::Delete
EXTRN	?AfxGetInstanceHandle@@YGPAUHINSTANCE__@@XZ:PROC ; AfxGetInstanceHandle
EXTRN	??0CCommandLineInfo@@QAE@XZ:PROC		; CCommandLineInfo::CCommandLineInfo
EXTRN	??1CCommandLineInfo@@UAE@XZ:PROC		; CCommandLineInfo::~CCommandLineInfo
EXTRN	?GetRuntimeClass@CWinApp@@UBEPAUCRuntimeClass@@XZ:PROC ; CWinApp::GetRuntimeClass
EXTRN	??0CWinApp@@QAE@PB_W@Z:PROC			; CWinApp::CWinApp
EXTRN	?SetRegistryKey@CWinApp@@IAEXPB_W@Z:PROC	; CWinApp::SetRegistryKey
EXTRN	?GetProfileIntW@CWinApp@@UAEIPB_W0H@Z:PROC	; CWinApp::GetProfileIntW
EXTRN	?WriteProfileInt@CWinApp@@UAEHPB_W0H@Z:PROC	; CWinApp::WriteProfileInt
EXTRN	?GetProfileStringW@CWinApp@@UAE?AV?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@PB_W00@Z:PROC ; CWinApp::GetProfileStringW
EXTRN	?WriteProfileStringW@CWinApp@@UAEHPB_W00@Z:PROC	; CWinApp::WriteProfileStringW
EXTRN	?GetProfileBinary@CWinApp@@UAEHPB_W0PAPAEPAI@Z:PROC ; CWinApp::GetProfileBinary
EXTRN	?WriteProfileBinary@CWinApp@@UAEHPB_W0PAEI@Z:PROC ; CWinApp::WriteProfileBinary
EXTRN	?InitLibId@CWinApp@@UAEXXZ:PROC			; CWinApp::InitLibId
EXTRN	?Register@CWinApp@@UAEHXZ:PROC			; CWinApp::Register
EXTRN	?Unregister@CWinApp@@UAEHXZ:PROC		; CWinApp::Unregister
EXTRN	?OpenDocumentFile@CWinApp@@UAEPAVCDocument@@PB_W@Z:PROC ; CWinApp::OpenDocumentFile
EXTRN	?OpenDocumentFile@CWinApp@@UAEPAVCDocument@@PB_WH@Z:PROC ; CWinApp::OpenDocumentFile
EXTRN	?AddToRecentFileList@CWinApp@@UAEXPB_W@Z:PROC	; CWinApp::AddToRecentFileList
EXTRN	?ParseCommandLine@CWinApp@@QAEXAAVCCommandLineInfo@@@Z:PROC ; CWinApp::ParseCommandLine
EXTRN	?InitApplication@CWinApp@@UAEHXZ:PROC		; CWinApp::InitApplication
EXTRN	?SaveAllModified@CWinApp@@UAEHXZ:PROC		; CWinApp::SaveAllModified
EXTRN	?DoMessageBox@CWinApp@@UAEHPB_WII@Z:PROC	; CWinApp::DoMessageBox
EXTRN	?DoWaitCursor@CWinApp@@UAEXH@Z:PROC		; CWinApp::DoWaitCursor
EXTRN	?OnDDECommand@CWinApp@@UAEHPA_W@Z:PROC		; CWinApp::OnDDECommand
EXTRN	?WinHelpW@CWinApp@@UAEXKI@Z:PROC		; CWinApp::WinHelpW
EXTRN	?HtmlHelpW@CWinApp@@UAEXKI@Z:PROC		; CWinApp::HtmlHelpW
EXTRN	?WinHelpInternal@CWinApp@@UAEXKI@Z:PROC		; CWinApp::WinHelpInternal
EXTRN	?RegisterWithRestartManager@CWinApp@@UAEJHABV?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@@Z:PROC ; CWinApp::RegisterWithRestartManager
EXTRN	?RegisterWithRestartManager@CWinApp@@UAEJPB_WKP6GKPAX@Z1KK@Z:PROC ; CWinApp::RegisterWithRestartManager
EXTRN	?ApplicationRecoveryCallback@CWinApp@@UAEKPAX@Z:PROC ; CWinApp::ApplicationRecoveryCallback
EXTRN	?GetDataRecoveryHandler@CWinApp@@UAEPAVCDataRecoveryHandler@@XZ:PROC ; CWinApp::GetDataRecoveryHandler
EXTRN	?IsTaskbarInteractionEnabled@CWinApp@@UAEHXZ:PROC ; CWinApp::IsTaskbarInteractionEnabled
EXTRN	?InitInstance@CWinApp@@UAEHXZ:PROC		; CWinApp::InitInstance
EXTRN	?ExitInstance@CWinApp@@UAEHXZ:PROC		; CWinApp::ExitInstance
EXTRN	?RestartInstance@CWinApp@@UAEHXZ:PROC		; CWinApp::RestartInstance
EXTRN	?Run@CWinApp@@UAEHXZ:PROC			; CWinApp::Run
EXTRN	?OnIdle@CWinApp@@UAEHJ@Z:PROC			; CWinApp::OnIdle
EXTRN	?ProcessWndProcException@CWinApp@@UAEJPAVCException@@PBUtagMSG@@@Z:PROC ; CWinApp::ProcessWndProcException
EXTRN	?LoadAppLangResourceDLL@CWinApp@@UAEPAUHINSTANCE__@@XZ:PROC ; CWinApp::LoadAppLangResourceDLL
EXTRN	??1CWinApp@@UAE@XZ:PROC				; CWinApp::~CWinApp
EXTRN	?AssertValid@CWinApp@@UBEXXZ:PROC		; CWinApp::AssertValid
EXTRN	?Dump@CWinApp@@UBEXAAVCDumpContext@@@Z:PROC	; CWinApp::Dump
EXTRN	?LoadSysPolicies@CWinApp@@UAEHXZ:PROC		; CWinApp::LoadSysPolicies
EXTRN	?AfxMessageBox@@YGHIII@Z:PROC			; AfxMessageBox
EXTRN	?RegisterAll@COleObjectFactory@@SGHXZ:PROC	; COleObjectFactory::RegisterAll
EXTRN	?UpdateRegistryAll@COleObjectFactory@@SGHH@Z:PROC ; COleObjectFactory::UpdateRegistryAll
EXTRN	?AfxOleRegisterTypeLib@@YGHPAUHINSTANCE__@@ABU_GUID@@PB_W2@Z:PROC ; AfxOleRegisterTypeLib
EXTRN	?AfxOleUnregisterTypeLib@@YGHABU_GUID@@GGK@Z:PROC ; AfxOleUnregisterTypeLib
EXTRN	?AfxOleInit@@YGHXZ:PROC				; AfxOleInit
EXTRN	?AfxOleTerm@@YGXH@Z:PROC			; AfxOleTerm
EXTRN	?AfxEnableControlContainer@@YAXPAVCOccManager@@@Z:PROC ; AfxEnableControlContainer
EXTRN	?SetDefaultManager@CMFCVisualManager@@SGXPAUCRuntimeClass@@@Z:PROC ; CMFCVisualManager::SetDefaultManager
EXTRN	??0CShellManager@@QAE@XZ:PROC			; CShellManager::CShellManager
EXTRN	?GetThisClass@CMFCVisualManagerWindows@@SGPAUCRuntimeClass@@XZ:PROC ; CMFCVisualManagerWindows::GetThisClass
EXTRN	??_ECLianliankanApp@@UAEPAXI@Z:PROC		; CLianliankanApp::`vector deleting destructor'
EXTRN	??0CLLKDlg@@QAE@PAVCWnd@@@Z:PROC		; CLLKDlg::CLLKDlg
EXTRN	??1CLLKDlg@@UAE@XZ:PROC				; CLLKDlg::~CLLKDlg
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
_BSS	SEGMENT
?theApp@@3VCLianliankanApp@@A DB 0ccH DUP (?)		; theApp
_BSS	ENDS
CRT$XCU	SEGMENT
?theApp$initializer$@@3P6AXXZA DD FLAT:??__EtheApp@@YAXXZ ; theApp$initializer$
CRT$XCU	ENDS
;	COMDAT ??_R2CWinThread@@8
rdata$r	SEGMENT
??_R2CWinThread@@8 DD FLAT:??_R1A@?0A@EA@CWinThread@@8	; CWinThread::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CWinThread@@8
rdata$r	SEGMENT
??_R3CWinThread@@8 DD 00H				; CWinThread::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CWinThread@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWinThread@@@8
data$r	SEGMENT
??_R0?AVCWinThread@@@8 DD FLAT:??_7type_info@@6B@	; CWinThread `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWinThread@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWinThread@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWinThread@@8 DD FLAT:??_R0?AVCWinThread@@@8 ; CWinThread::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWinThread@@8
rdata$r	ENDS
;	COMDAT ??_R2CWinApp@@8
rdata$r	SEGMENT
??_R2CWinApp@@8 DD FLAT:??_R1A@?0A@EA@CWinApp@@8	; CWinApp::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWinThread@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CWinApp@@8
rdata$r	SEGMENT
??_R3CWinApp@@8 DD 00H					; CWinApp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CWinApp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWinApp@@@8
data$r	SEGMENT
??_R0?AVCWinApp@@@8 DD FLAT:??_7type_info@@6B@		; CWinApp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWinApp@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CWinApp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWinApp@@8 DD FLAT:??_R0?AVCWinApp@@@8	; CWinApp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWinApp@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CLianliankanApp@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CLianliankanApp@@8 DD FLAT:??_R0?AVCLianliankanApp@@@8 ; CLianliankanApp::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLianliankanApp@@8
rdata$r	ENDS
;	COMDAT ??_R2CLianliankanApp@@8
rdata$r	SEGMENT
??_R2CLianliankanApp@@8 DD FLAT:??_R1A@?0A@EA@CLianliankanApp@@8 ; CLianliankanApp::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWinApp@@8
	DD	FLAT:??_R1A@?0A@EA@CWinThread@@8
	DD	FLAT:??_R1A@?0A@EA@CCmdTarget@@8
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CLianliankanApp@@8
rdata$r	SEGMENT
??_R3CLianliankanApp@@8 DD 00H				; CLianliankanApp::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CLianliankanApp@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLianliankanApp@@@8
data$r	SEGMENT
??_R0?AVCLianliankanApp@@@8 DD FLAT:??_7type_info@@6B@	; CLianliankanApp `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLianliankanApp@@', 00H
data$r	ENDS
;	COMDAT ??_R4CLianliankanApp@@6B@
rdata$r	SEGMENT
??_R4CLianliankanApp@@6B@ DD 00H			; CLianliankanApp::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLianliankanApp@@@8
	DD	FLAT:??_R3CLianliankanApp@@8
rdata$r	ENDS
;	COMDAT ??_C@_0FH@ONNGIDCE@?$LO?$KP?$LI?f?3?5?H?g?$LJ?$PL?D?z?T?Z?$LG?T?$LL?$LA?$LP?r?I?O?J?$LJ?S?C?5MFC?5?$LP@
CONST	SEGMENT
??_C@_0FH@ONNGIDCE@?$LO?$KP?$LI?f?3?5?H?g?$LJ?$PL?D?z?T?Z?$LG?T?$LL?$LA?$LP?r?I?O?J?$LJ?S?C?5MFC?5?$LP@ DB 0beH
	DB	0afH, 0b8H, 0e6H, ': ', 0c8H, 0e7H, 0b9H, 0fbH, 0c4H, 0faH, 0d4H
	DB	0daH, 0b6H, 0d4H, 0bbH, 0b0H, 0bfH, 0f2H, 0c9H, 0cfH, 0caH, 0b9H
	DB	0d3H, 0c3H, ' MFC ', 0bfH, 0d8H, 0bcH, 0feH, 0a3H, 0acH, 0d4H, 0f2H
	DB	0ceH, 0deH, 0b7H, 0a8H, ' #define _AFX_NO_MFC_CONTROLS_IN_DIAL'
	DB	'OGS', 0a1H, 0a3H, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BCKBGNML@?$LO?$KP?$LI?f?3?5?$LG?T?$LL?$LA?$LP?r?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM?$KD?$KM?S?$KG?S?C?$LD?L?P?r?$LN?$KL@
CONST	SEGMENT
??_C@_0CM@BCKBGNML@?$LO?$KP?$LI?f?3?5?$LG?T?$LL?$LA?$LP?r?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM?$KD?$KM?S?$KG?S?C?$LD?L?P?r?$LN?$KL@ DB 0beH
	DB	0afH, 0b8H, 0e6H, ': ', 0b6H, 0d4H, 0bbH, 0b0H, 0bfH, 0f2H, 0b4H
	DB	0b4H, 0bdH, 0a8H, 0caH, 0a7H, 0b0H, 0dcH, 0a3H, 0acH, 0d3H, 0a6H
	DB	0d3H, 0c3H, 0b3H, 0ccH, 0d0H, 0f2H, 0bdH, 0abH, 0d2H, 0e2H, 0cdH
	DB	0e2H, 0d6H, 0d5H, 0d6H, 0b9H, 0a1H, 0a3H, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CA@KINOLAIL@?$FO?$JEu?$CIz?$AL?$FO?$IPT?$BB?$FL?$PMu?$BPb?$BAv?$IEg?0W0?$FO?$JEu?$CIz?$AL?$FO?$IP?$AA?$AA@
CONST	SEGMENT
??_C@_1CA@KINOLAIL@?$FO?$JEu?$CIz?$AL?$FO?$IPT?$BB?$FL?$PMu?$BPb?$BAv?$IEg?0W0?$FO?$JEu?$CIz?$AL?$FO?$IP?$AA?$AA@ DB 094H
	DB	'^(u', 0bH, 'z', 08fH, '^', 011H, 'T', 0fcH, '[', 01fH, 'u', 010H
	DB	'b', 084H, 'v,g0W', 094H, '^(u', 0bH, 'z', 08fH, '^', 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@
CONST	SEGMENT
??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@ DB 'd'
	DB	':\study\', 0caH, 0fdH, 0beH, 0ddH, 0bdH, 0e1H, 0b9H, 0b9H, 0d3H
	DB	0ebH, 0cbH, 0e3H, 0b7H, 0a8H, 0d7H, 0dbH, 0baH, 0cfH, 0caH, 0b5H
	DB	0d1H, 0e9H, '\', 0c1H, 0acH, 0c1H, 0acH, 0bfH, 0b4H, 0d3H, 0ceH
	DB	0cfH, 0b7H, '\llkpro17.6.18\lianliankan\lianliankan.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA
_DATA	SEGMENT
?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA DD 033H ; `CLianliankanApp::InitInstance'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_7CLianliankanApp@@6B@
CONST	SEGMENT
??_7CLianliankanApp@@6B@ DD FLAT:??_R4CLianliankanApp@@6B@ ; CLianliankanApp::`vftable'
	DD	FLAT:?GetRuntimeClass@CWinApp@@UBEPAUCRuntimeClass@@XZ
	DD	FLAT:??_ECLianliankanApp@@UAEPAXI@Z
	DD	FLAT:?Serialize@CObject@@UAEXAAVCArchive@@@Z
	DD	FLAT:?AssertValid@CWinApp@@UBEXXZ
	DD	FLAT:?Dump@CWinApp@@UBEXAAVCDumpContext@@@Z
	DD	FLAT:?OnCmdMsg@CCmdTarget@@UAEHIHPAXPAUAFX_CMDHANDLERINFO@@@Z
	DD	FLAT:?OnFinalRelease@CCmdTarget@@UAEXXZ
	DD	FLAT:?IsInvokeAllowed@CCmdTarget@@UAEHJ@Z
	DD	FLAT:?GetDispatchIID@CCmdTarget@@UAEHPAU_GUID@@@Z
	DD	FLAT:?GetTypeInfoCount@CCmdTarget@@UAEIXZ
	DD	FLAT:?GetTypeLibCache@CCmdTarget@@UAEPAVCTypeLibCache@@XZ
	DD	FLAT:?GetTypeLib@CCmdTarget@@UAEJKPAPAUITypeLib@@@Z
	DD	FLAT:?GetMessageMap@CLianliankanApp@@MBEPBUAFX_MSGMAP@@XZ
	DD	FLAT:?GetCommandMap@CCmdTarget@@MBEPBUAFX_OLECMDMAP@@XZ
	DD	FLAT:?GetDispatchMap@CCmdTarget@@MBEPBUAFX_DISPMAP@@XZ
	DD	FLAT:?GetConnectionMap@CCmdTarget@@MBEPBUAFX_CONNECTIONMAP@@XZ
	DD	FLAT:?GetInterfaceMap@CCmdTarget@@MBEPBUAFX_INTERFACEMAP@@XZ
	DD	FLAT:?GetEventSinkMap@CCmdTarget@@MBEPBUAFX_EVENTSINKMAP@@XZ
	DD	FLAT:?OnCreateAggregates@CCmdTarget@@UAEHXZ
	DD	FLAT:?GetInterfaceHook@CCmdTarget@@UAEPAUIUnknown@@PBX@Z
	DD	FLAT:?GetExtraConnectionPoints@CCmdTarget@@MAEHPAVCPtrArray@@@Z
	DD	FLAT:?GetConnectionHook@CCmdTarget@@MAEPAUIConnectionPoint@@ABU_GUID@@@Z
	DD	FLAT:?InitInstance@CLianliankanApp@@UAEHXZ
	DD	FLAT:?Run@CWinApp@@UAEHXZ
	DD	FLAT:?PreTranslateMessage@CWinThread@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?PumpMessage@CWinThread@@UAEHXZ
	DD	FLAT:?OnIdle@CWinApp@@UAEHJ@Z
	DD	FLAT:?IsIdleMessage@CWinThread@@UAEHPAUtagMSG@@@Z
	DD	FLAT:?ExitInstance@CLianliankanApp@@UAEHXZ
	DD	FLAT:?ProcessWndProcException@CWinApp@@UAEJPAVCException@@PBUtagMSG@@@Z
	DD	FLAT:?ProcessMessageFilter@CWinThread@@UAEHHPAUtagMSG@@@Z
	DD	FLAT:?GetMainWnd@CWinThread@@UAEPAVCWnd@@XZ
	DD	FLAT:?Delete@CWinThread@@UAEXXZ
	DD	FLAT:?GetProfileIntW@CWinApp@@UAEIPB_W0H@Z
	DD	FLAT:?WriteProfileInt@CWinApp@@UAEHPB_W0H@Z
	DD	FLAT:?GetProfileStringW@CWinApp@@UAE?AV?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@PB_W00@Z
	DD	FLAT:?WriteProfileStringW@CWinApp@@UAEHPB_W00@Z
	DD	FLAT:?GetProfileBinary@CWinApp@@UAEHPB_W0PAPAEPAI@Z
	DD	FLAT:?WriteProfileBinary@CWinApp@@UAEHPB_W0PAEI@Z
	DD	FLAT:?InitLibId@CWinApp@@UAEXXZ
	DD	FLAT:?Register@CWinApp@@UAEHXZ
	DD	FLAT:?Unregister@CWinApp@@UAEHXZ
	DD	FLAT:?OpenDocumentFile@CWinApp@@UAEPAVCDocument@@PB_WH@Z
	DD	FLAT:?OpenDocumentFile@CWinApp@@UAEPAVCDocument@@PB_W@Z
	DD	FLAT:?AddToRecentFileList@CWinApp@@UAEXPB_W@Z
	DD	FLAT:?InitApplication@CWinApp@@UAEHXZ
	DD	FLAT:?SaveAllModified@CWinApp@@UAEHXZ
	DD	FLAT:?DoMessageBox@CWinApp@@UAEHPB_WII@Z
	DD	FLAT:?DoWaitCursor@CWinApp@@UAEXH@Z
	DD	FLAT:?OnDDECommand@CWinApp@@UAEHPA_W@Z
	DD	FLAT:?WinHelpW@CWinApp@@UAEXKI@Z
	DD	FLAT:?HtmlHelpW@CWinApp@@UAEXKI@Z
	DD	FLAT:?WinHelpInternal@CWinApp@@UAEXKI@Z
	DD	FLAT:?RegisterWithRestartManager@CWinApp@@UAEJPB_WKP6GKPAX@Z1KK@Z
	DD	FLAT:?RegisterWithRestartManager@CWinApp@@UAEJHABV?$CStringT@_WV?$StrTraitMFC_DLL@_WV?$ChTraitsCRT@_W@ATL@@@@@ATL@@@Z
	DD	FLAT:?ApplicationRecoveryCallback@CWinApp@@UAEKPAX@Z
	DD	FLAT:?SupportsRestartManager@CWinApp@@UBEHXZ
	DD	FLAT:?SupportsApplicationRecovery@CWinApp@@UBEHXZ
	DD	FLAT:?SupportsAutosaveAtRestart@CWinApp@@UBEHXZ
	DD	FLAT:?SupportsAutosaveAtInterval@CWinApp@@UBEHXZ
	DD	FLAT:?ReopenPreviousFilesAtRestart@CWinApp@@UBEHXZ
	DD	FLAT:?RestoreAutosavedFilesAtRestart@CWinApp@@UBEHXZ
	DD	FLAT:?GetApplicationRestartFlags@CWinApp@@UAEKXZ
	DD	FLAT:?GetApplicationRecoveryParameter@CWinApp@@UAEPAXXZ
	DD	FLAT:?GetApplicationRecoveryPingInterval@CWinApp@@UAEKXZ
	DD	FLAT:?GetDataRecoveryHandler@CWinApp@@UAEPAVCDataRecoveryHandler@@XZ
	DD	FLAT:?IsTaskbarInteractionEnabled@CWinApp@@UAEHXZ
	DD	FLAT:?RestartInstance@CWinApp@@UAEHXZ
	DD	FLAT:?LoadAppLangResourceDLL@CWinApp@@UAEPAUHINSTANCE__@@XZ
	DD	FLAT:?LoadSysPolicies@CWinApp@@UAEHXZ
CONST	ENDS
;	COMDAT ??_R2CCmdTarget@@8
rdata$r	SEGMENT
??_R2CCmdTarget@@8 DD FLAT:??_R1A@?0A@EA@CCmdTarget@@8	; CCmdTarget::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CCmdTarget@@8
rdata$r	SEGMENT
??_R3CCmdTarget@@8 DD 00H				; CCmdTarget::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCmdTarget@@@8
data$r	SEGMENT
??_R0?AVCCmdTarget@@@8 DD FLAT:??_7type_info@@6B@	; CCmdTarget `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCmdTarget@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCmdTarget@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCmdTarget@@8 DD FLAT:??_R0?AVCCmdTarget@@@8 ; CCmdTarget::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCmdTarget@@8
rdata$r	ENDS
;	COMDAT ??_R2CObject@@8
rdata$r	SEGMENT
??_R2CObject@@8 DD FLAT:??_R1A@?0A@EA@CObject@@8	; CObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CObject@@8
rdata$r	SEGMENT
??_R3CObject@@8 DD 00H					; CObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCObject@@@8
data$r	SEGMENT
??_R0?AVCObject@@@8 DD FLAT:??_7type_info@@6B@		; CObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCObject@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CObject@@8 DD FLAT:??_R0?AVCObject@@@8	; CObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CObject@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@ DB '%', 00H, 'h', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H
	DB	'l', 00H, 's', 00H, '%', 00H, 'l', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 'u'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H
	DB	'l', 00H, 's', 00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
;	COMDAT ??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@
CONST	SEGMENT
??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@ DB 'd'
	DB	00H, ':', 00H, '\', 00H, 'd', 00H, 'e', 00H, 'v', 00H, 'e', 00H
	DB	'l', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'm'
	DB	00H, 'i', 00H, 'c', 00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H
	DB	'f', 00H, 't', 00H, ' ', 00H, 'v', 00H, 'i', 00H, 's', 00H, 'u'
	DB	00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 't', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '0', 00H, '\', 00H, 'v', 00H, 'c', 00H, '\', 00H, 'a', 00H
	DB	't', 00H, 'l', 00H, 'm', 00H, 'f', 00H, 'c', 00H, '\', 00H, 'i'
	DB	00H, 'n', 00H, 'c', 00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H
	DB	'\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InitInstance@CLianliankanApp@@UAEHXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$2
__ehfuncinfo$?InitInstance@CLianliankanApp@@UAEHXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?InitInstance@CLianliankanApp@@UAEHXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FtheApp@@YAXXZ
text$yd	SEGMENT
??__FtheApp@@YAXXZ PROC					; `dynamic atexit destructor for 'theApp'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?theApp@@3VCLianliankanApp@@A ; theApp
  00005	e9 00 00 00 00	 jmp	 ??1CWinApp@@UAE@XZ	; CWinApp::~CWinApp
??__FtheApp@@YAXXZ ENDP					; `dynamic atexit destructor for 'theApp''
text$yd	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ??__EtheApp@@YAXXZ
text$di	SEGMENT
??__EtheApp@@YAXXZ PROC					; `dynamic initializer for 'theApp'', COMDAT

; 29   : {

  00000	6a 00		 push	 0
  00002	b9 00 00 00 00	 mov	 ecx, OFFSET ?theApp@@3VCLianliankanApp@@A ; theApp
  00007	e8 00 00 00 00	 call	 ??0CWinApp@@QAE@PB_W@Z	; CWinApp::CWinApp

; 40   : CLianliankanApp theApp;

  0000c	68 00 00 00 00	 push	 OFFSET ??__FtheApp@@YAXXZ ; `dynamic atexit destructor for 'theApp''

; 29   : {

  00011	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?theApp@@3VCLianliankanApp@@A, OFFSET ??_7CLianliankanApp@@6B@

; 30   : 	// 支持重新启动管理器
; 31   : 	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;

  0001b	c7 05 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?theApp@@3VCLianliankanApp@@A+172, 1

; 40   : CLianliankanApp theApp;

  00025	e8 00 00 00 00	 call	 _atexit
  0002a	59		 pop	 ecx
  0002b	c3		 ret	 0
??__EtheApp@@YAXXZ ENDP					; `dynamic initializer for 'theApp''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CLLKDlg@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CLLKDlg@@QAEXI@Z PROC			; CLLKDlg::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CLLKDlg@@QAEXI@Z ENDP			; CLLKDlg::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCLianliankanApp@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLianliankanApp@@UAEPAXI@Z PROC			; CLianliankanApp::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CWinApp@@UAE@XZ	; CWinApp::~CWinApp
  0000b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000e	a8 01		 test	 al, 1
  00010	74 1f		 je	 SHORT $LN10@scalar
  00012	a8 04		 test	 al, 4
  00014	75 0d		 jne	 SHORT $LN3@scalar
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3CObject@@SGXPAX@Z	; CObject::operator delete
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN3@scalar:
  00023	68 cc 00 00 00	 push	 204			; 000000ccH
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?__global_delete@@YAXPAXI@Z ; __global_delete
  0002e	83 c4 08	 add	 esp, 8
$LN10@scalar:
  00031	8b c6		 mov	 eax, esi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
??_GCLianliankanApp@@UAEPAXI@Z ENDP			; CLianliankanApp::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@CLianliankanApp@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@CLianliankanApp@@QAEXI@Z PROC		; CLianliankanApp::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@CLianliankanApp@@QAEXI@Z ENDP		; CLianliankanApp::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1CLianliankanApp@@UAE@XZ
_TEXT	SEGMENT
??1CLianliankanApp@@UAE@XZ PROC				; CLianliankanApp::~CLianliankanApp, COMDAT
; _this$ = ecx
  00000	e9 00 00 00 00	 jmp	 ??1CWinApp@@UAE@XZ	; CWinApp::~CWinApp
??1CLianliankanApp@@UAE@XZ ENDP				; CLianliankanApp::~CLianliankanApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?GetMessageMap@CLianliankanApp@@MBEPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetMessageMap@CLianliankanApp@@MBEPBUAFX_MSGMAP@@XZ PROC ; CLianliankanApp::GetMessageMap, COMDAT
; _this$ = ecx

; 21   : BEGIN_MESSAGE_MAP(CLianliankanApp, CWinApp)

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetMessageMap@CLianliankanApp@@MBEPBUAFX_MSGMAP@@XZ ENDP ; CLianliankanApp::GetMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ
_TEXT	SEGMENT
?GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ PROC ; CLianliankanApp::GetThisMessageMap, COMDAT

; 22   : 	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
; 23   : END_MESSAGE_MAP()

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?messageMap@?1??GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ@4U3@B
  00005	c3		 ret	 0
?GetThisMessageMap@CLianliankanApp@@KGPBUAFX_MSGMAP@@XZ ENDP ; CLianliankanApp::GetThisMessageMap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?ExitInstance@CLianliankanApp@@UAEHXZ
_TEXT	SEGMENT
?ExitInstance@CLianliankanApp@@UAEHXZ PROC		; CLianliankanApp::ExitInstance, COMDAT
; _this$ = ecx

; 153  : {

  00000	56		 push	 esi

; 154  : 	AfxOleTerm(FALSE);

  00001	6a 00		 push	 0
  00003	8b f1		 mov	 esi, ecx
  00005	e8 00 00 00 00	 call	 ?AfxOleTerm@@YGXH@Z	; AfxOleTerm

; 155  : 
; 156  : 	return CWinApp::ExitInstance();

  0000a	8b ce		 mov	 ecx, esi
  0000c	5e		 pop	 esi
  0000d	e9 00 00 00 00	 jmp	 ?ExitInstance@CWinApp@@UAEHXZ ; CWinApp::ExitInstance
?ExitInstance@CLianliankanApp@@UAEHXZ ENDP		; CLianliankanApp::ExitInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?InitInstance@CLianliankanApp@@UAEHXZ
_TEXT	SEGMENT
$T2 = -316						; size = 8
$T3 = -316						; size = 8
$T4 = -312						; size = 4
_MainDlg$ = -308					; size = 240
_cmdInfo$ = -68						; size = 44
_InitCtrls$ = -24					; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?InitInstance@CLianliankanApp@@UAEHXZ PROC		; CLianliankanApp::InitInstance, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InitInstance@CLianliankanApp@@UAEHXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx

; 52   : 	// 如果一个运行在 Windows XP 上的应用程序清单指定要
; 53   : 	// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式，
; 54   : 	//则需要 InitCommonControlsEx()。否则，将无法创建窗口。
; 55   : 	INITCOMMONCONTROLSEX InitCtrls;
; 56   : 	InitCtrls.dwSize = sizeof(InitCtrls);
; 57   : 	// 将它设置为包括所有要在应用程序中使用的
; 58   : 	// 公共控件类。
; 59   : 	InitCtrls.dwICC = ICC_WIN95_CLASSES;
; 60   : 	InitCommonControlsEx(&InitCtrls);

  0002f	8d 45 e8	 lea	 eax, DWORD PTR _InitCtrls$[ebp]
  00032	c7 45 e8 08 00
	00 00		 mov	 DWORD PTR _InitCtrls$[ebp], 8
  00039	50		 push	 eax
  0003a	c7 45 ec ff 00
	00 00		 mov	 DWORD PTR _InitCtrls$[ebp+4], 255 ; 000000ffH
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitCommonControlsEx@4

; 61   : 
; 62   : 	CWinApp::InitInstance();

  00047	8b cf		 mov	 ecx, edi
  00049	e8 00 00 00 00	 call	 ?InitInstance@CWinApp@@UAEHXZ ; CWinApp::InitInstance

; 63   : 
; 64   : 
; 65   : 	// 初始化 OLE 库
; 66   : 	if (!AfxOleInit())

  0004e	e8 00 00 00 00	 call	 ?AfxOleInit@@YGHXZ	; AfxOleInit
  00053	85 c0		 test	 eax, eax
  00055	75 0f		 jne	 SHORT $LN2@InitInstan

; 67   : 	{
; 68   : 		AfxMessageBox(IDP_OLE_INIT_FAILED);

  00057	6a ff		 push	 -1
  00059	50		 push	 eax
  0005a	6a 64		 push	 100			; 00000064H
  0005c	e8 00 00 00 00	 call	 ?AfxMessageBox@@YGHIII@Z ; AfxMessageBox

; 69   : 		return FALSE;

  00061	e9 99 01 00 00	 jmp	 $LN37@InitInstan
$LN2@InitInstan:

; 70   : 	}
; 71   : 
; 72   : 	AfxEnableControlContainer();

  00066	6a 00		 push	 0
  00068	e8 00 00 00 00	 call	 ?AfxEnableControlContainer@@YAXPAVCOccManager@@@Z ; AfxEnableControlContainer

; 73   : 
; 74   : 	// 创建 shell 管理器，以防对话框包含
; 75   : 	// 任何 shell 树视图控件或 shell 列表视图控件。
; 76   : 	CShellManager *pShellManager = new CShellManager;

  0006d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA
  00072	83 c4 04	 add	 esp, 4
  00075	83 c0 19	 add	 eax, 25			; 00000019H
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@
  0007e	6a 0c		 push	 12			; 0000000cH
  00080	e8 00 00 00 00	 call	 ??2CObject@@SGPAXIPBDH@Z ; CObject::operator new
  00085	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  0008b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00092	85 c0		 test	 eax, eax
  00094	74 0b		 je	 SHORT $LN16@InitInstan
  00096	8b c8		 mov	 ecx, eax
  00098	e8 00 00 00 00	 call	 ??0CShellManager@@QAE@XZ ; CShellManager::CShellManager
  0009d	8b f0		 mov	 esi, eax
  0009f	eb 02		 jmp	 SHORT $LN17@InitInstan
$LN16@InitInstan:
  000a1	33 f6		 xor	 esi, esi
$LN17@InitInstan:
  000a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 77   : 
; 78   : 	// 激活“Windows Native”视觉管理器，以便在 MFC 控件中启用主题
; 79   : 	CMFCVisualManager::SetDefaultManager(RUNTIME_CLASS(CMFCVisualManagerWindows));

  000aa	e8 00 00 00 00	 call	 ?GetThisClass@CMFCVisualManagerWindows@@SGPAUCRuntimeClass@@XZ ; CMFCVisualManagerWindows::GetThisClass
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ?SetDefaultManager@CMFCVisualManager@@SGXPAUCRuntimeClass@@@Z ; CMFCVisualManager::SetDefaultManager

; 80   : 
; 81   : 	// 标准初始化
; 82   : 	// 如果未使用这些功能并希望减小
; 83   : 	// 最终可执行文件的大小，则应移除下列
; 84   : 	// 不需要的特定初始化例程
; 85   : 	// 更改用于存储设置的注册表项
; 86   : 	// TODO: 应适当修改该字符串，
; 87   : 	// 例如修改为公司或组织名
; 88   : 	SetRegistryKey(_T("应用程序向导生成的本地应用程序"));

  000b5	68 00 00 00 00	 push	 OFFSET ??_C@_1CA@KINOLAIL@?$FO?$JEu?$CIz?$AL?$FO?$IPT?$BB?$FL?$PMu?$BPb?$BAv?$IEg?0W0?$FO?$JEu?$CIz?$AL?$FO?$IP?$AA?$AA@
  000ba	8b cf		 mov	 ecx, edi
  000bc	e8 00 00 00 00	 call	 ?SetRegistryKey@CWinApp@@IAEXPB_W@Z ; CWinApp::SetRegistryKey

; 89   : 	// 分析自动化开关或注册/注销开关的命令行。
; 90   : 	CCommandLineInfo cmdInfo;

  000c1	8d 4d bc	 lea	 ecx, DWORD PTR _cmdInfo$[ebp]
  000c4	e8 00 00 00 00	 call	 ??0CCommandLineInfo@@QAE@XZ ; CCommandLineInfo::CCommandLineInfo

; 91   : 	ParseCommandLine(cmdInfo);

  000c9	8d 45 bc	 lea	 eax, DWORD PTR _cmdInfo$[ebp]
  000cc	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000d3	50		 push	 eax
  000d4	8b cf		 mov	 ecx, edi
  000d6	e8 00 00 00 00	 call	 ?ParseCommandLine@CWinApp@@QAEXAAVCCommandLineInfo@@@Z ; CWinApp::ParseCommandLine

; 92   : 
; 93   : 	// 应用程序是用 /Embedding 或 /Automation 开关启动的。
; 94   : 	//使应用程序作为自动化服务器运行。
; 95   : 	if (cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)

  000db	83 7d c4 00	 cmp	 DWORD PTR _cmdInfo$[ebp+8], 0
  000df	75 4e		 jne	 SHORT $LN5@InitInstan
  000e1	83 7d c8 00	 cmp	 DWORD PTR _cmdInfo$[ebp+12], 0
  000e5	75 48		 jne	 SHORT $LN5@InitInstan

; 99   : 	}
; 100  : 	// 应用程序是用 /Unregserver 或 /Unregister 开关启动的。  移除
; 101  : 	// 注册表中的项。
; 102  : 	else if (cmdInfo.m_nShellCommand == CCommandLineInfo::AppUnregister)

  000e7	83 7d d0 07	 cmp	 DWORD PTR _cmdInfo$[ebp+20], 7
  000eb	75 1c		 jne	 SHORT $LN6@InitInstan

; 103  : 	{
; 104  : 		COleObjectFactory::UpdateRegistryAll(FALSE);

  000ed	6a 00		 push	 0
  000ef	e8 00 00 00 00	 call	 ?UpdateRegistryAll@COleObjectFactory@@SGHH@Z ; COleObjectFactory::UpdateRegistryAll

; 105  : 		AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor);

  000f4	6a 00		 push	 0
  000f6	6a 00		 push	 0
  000f8	6a 01		 push	 1
  000fa	68 00 00 00 00	 push	 OFFSET ?_tlid@@3U_GUID@@B
  000ff	e8 00 00 00 00	 call	 ?AfxOleUnregisterTypeLib@@YGHABU_GUID@@GGK@Z ; AfxOleUnregisterTypeLib
  00104	e9 ee 00 00 00	 jmp	 $LN24@InitInstan
$LN6@InitInstan:

; 106  : 		return FALSE;
; 107  : 	}
; 108  : 	// 应用程序是以独立方式或用其他开关(如 /Register
; 109  : 	// 或 /Regserver)启动的。  更新注册表项，包括类型库。
; 110  : 	else
; 111  : 	{
; 112  : 		COleObjectFactory::UpdateRegistryAll();

  00109	6a 01		 push	 1
  0010b	e8 00 00 00 00	 call	 ?UpdateRegistryAll@COleObjectFactory@@SGHH@Z ; COleObjectFactory::UpdateRegistryAll

; 113  : 		AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid);

  00110	6a 00		 push	 0
  00112	6a 00		 push	 0
  00114	68 00 00 00 00	 push	 OFFSET ?_tlid@@3U_GUID@@B
  00119	e8 00 00 00 00	 call	 ?AfxGetInstanceHandle@@YGPAUHINSTANCE__@@XZ ; AfxGetInstanceHandle
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 ?AfxOleRegisterTypeLib@@YGHPAUHINSTANCE__@@ABU_GUID@@PB_W2@Z ; AfxOleRegisterTypeLib

; 114  : 		if (cmdInfo.m_nShellCommand == CCommandLineInfo::AppRegister)

  00124	83 7d d0 06	 cmp	 DWORD PTR _cmdInfo$[ebp+20], 6
  00128	75 0a		 jne	 SHORT $LN8@InitInstan
  0012a	e9 c8 00 00 00	 jmp	 $LN24@InitInstan
$LN5@InitInstan:

; 96   : 	{
; 97   : 		// 通过 CoRegisterClassObject() 注册类工厂。
; 98   : 		COleTemplateServer::RegisterAll();

  0012f	e8 00 00 00 00	 call	 ?RegisterAll@COleObjectFactory@@SGHXZ ; COleObjectFactory::RegisterAll
$LN8@InitInstan:
  00134	68 f0 00 00 00	 push	 240			; 000000f0H
  00139	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _MainDlg$[ebp]
  0013f	6a 00		 push	 0
  00141	50		 push	 eax
  00142	e8 00 00 00 00	 call	 _memset
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 115  : 			return FALSE;
; 116  : 	}
; 117  : 
; 118  : 	CLLKDlg MainDlg;

  0014a	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _MainDlg$[ebp]
  00150	6a 00		 push	 0
  00152	e8 00 00 00 00	 call	 ??0CLLKDlg@@QAE@PAVCWnd@@@Z ; CLLKDlg::CLLKDlg

; 119  : 	m_pMainWnd = &MainDlg;   // 将MainDlg设为主窗口 

  00157	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _MainDlg$[ebp]
  0015d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 120  : 	INT_PTR nResponse = MainDlg.DoModal();    //弹出对话框MainDlg，并将DoModal函数的返回值（退出时点击按钮的ID）赋值给nResponse 

  00161	8b c8		 mov	 ecx, eax
  00163	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00166	e8 00 00 00 00	 call	 ?DoModal@CDialog@@UAEHXZ ; CDialog::DoModal

; 121  : 	if (nResponse == IDOK)

  0016b	83 f8 01	 cmp	 eax, 1
  0016e	74 6f		 je	 SHORT $LN13@InitInstan

; 122  : 	{
; 123  : 		// TODO: 在此放置处理何时用
; 124  : 		//  “确定”来关闭对话框的代码
; 125  : 	}
; 126  : 	else if (nResponse == IDC_CANCEL)

  00170	3d f2 03 00 00	 cmp	 eax, 1010		; 000003f2H
  00175	74 68		 je	 SHORT $LN13@InitInstan

; 127  : 	{
; 128  : 		// TODO: 在此放置处理何时用
; 129  : 		//  “取消”来关闭对话框的代码
; 130  : 	}
; 131  : 	else if (nResponse == -1)

  00177	83 f8 ff	 cmp	 eax, -1
  0017a	75 63		 jne	 SHORT $LN13@InitInstan

; 133  : 		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");

  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA
  00181	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BCKBGNML@?$LO?$KP?$LI?f?3?5?$LG?T?$LL?$LA?$LP?r?$LE?$LE?$LN?$KI?J?$KH?$LA?$NM?$KD?$KM?S?$KG?S?C?$LD?L?P?r?$LN?$KL@
  00186	83 c0 52	 add	 eax, 82			; 00000052H
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  00189	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T3[ebp], OFFSET ??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp

; 133  : 		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");

  00193	6a 00		 push	 0
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  00195	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp+4], eax
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp

; 133  : 		TRACE(traceAppMsg, 0, "警告: 对话框创建失败，应用程序将意外终止。\n");

  0019b	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001a1	68 00 00 08 00	 push	 524288			; 00080000H
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()

; 134  : 		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");

  001ac	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_0FH@ONNGIDCE@?$LO?$KP?$LI?f?3?5?H?g?$LJ?$PL?D?z?T?Z?$LG?T?$LL?$LA?$LP?r?I?O?J?$LJ?S?C?5MFC?5?$LP@
  001b6	83 c0 53	 add	 eax, 83			; 00000053H
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  001b9	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], OFFSET ??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp

; 134  : 		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");

  001c3	6a 00		 push	 0
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  001c5	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp

; 134  : 		TRACE(traceAppMsg, 0, "警告: 如果您在对话框上使用 MFC 控件，则无法 #define _AFX_NO_MFC_CONTROLS_IN_DIALOGS。\n");

  001cb	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  001d1	68 00 00 08 00	 push	 524288			; 00080000H
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ ; ATL::CTraceFileAndLineInfo::operator()
  001dc	83 c4 20	 add	 esp, 32			; 00000020H
$LN13@InitInstan:

; 135  : 	}
; 136  : 
; 137  : 	// 删除上面创建的 shell 管理器。
; 138  : 	if (pShellManager != NULL)

  001df	85 f6		 test	 esi, esi
  001e1	74 09		 je	 SHORT $LN18@InitInstan

; 139  : 	{
; 140  : 		delete pShellManager;

  001e3	8b 06		 mov	 eax, DWORD PTR [esi]
  001e5	8b ce		 mov	 ecx, esi
  001e7	6a 01		 push	 1
  001e9	ff 50 04	 call	 DWORD PTR [eax+4]
$LN18@InitInstan:

; 141  : 	}
; 142  : 
; 143  : #ifndef _AFXDLL
; 144  : 	ControlBarCleanUp();
; 145  : #endif
; 146  : 
; 147  : 	// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序，
; 148  : 	//  而不是启动应用程序的消息泵。
; 149  : 	return FALSE;

  001ec	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _MainDlg$[ebp]
  001f2	e8 00 00 00 00	 call	 ??1CLLKDlg@@UAE@XZ	; CLLKDlg::~CLLKDlg
$LN24@InitInstan:
  001f7	8d 4d bc	 lea	 ecx, DWORD PTR _cmdInfo$[ebp]
  001fa	e8 00 00 00 00	 call	 ??1CCommandLineInfo@@UAE@XZ ; CCommandLineInfo::~CCommandLineInfo
$LN37@InitInstan:
  001ff	33 c0		 xor	 eax, eax

; 150  : }

  00201	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00204	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0020b	59		 pop	 ecx
  0020c	5f		 pop	 edi
  0020d	5e		 pop	 esi
  0020e	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00211	33 cd		 xor	 ecx, ebp
  00213	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00218	8b e5		 mov	 esp, ebp
  0021a	5d		 pop	 ebp
  0021b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$0:
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??InitInstance@CLianliankanApp@@UAEHXZ@4JA
  00005	83 c0 19	 add	 eax, 25			; 00000019H
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@MDEJBBLI@d?3?2study?2?J?$PN?$LO?$NN?$LN?a?$LJ?$LJ?S?k?K?c?$LH?$KI?W?$NL?$LK?O?J?$LF?Q?i?2@
  0000e	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3CObject@@SGXPAXPBDH@Z ; CObject::operator delete
  0001a	c3		 ret	 0
__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$1:
  0001b	8d 4d bc	 lea	 ecx, DWORD PTR _cmdInfo$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1CCommandLineInfo@@UAE@XZ ; CCommandLineInfo::~CCommandLineInfo
__unwindfunclet$?InitInstance@CLianliankanApp@@UAEHXZ$2:
  00023	8d 8d cc fe ff
	ff		 lea	 ecx, DWORD PTR _MainDlg$[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1CLLKDlg@@UAE@XZ	; CLLKDlg::~CLLKDlg
__ehhandler$?InitInstance@CLianliankanApp@@UAEHXZ:
  0002e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00032	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00035	8b 8a c4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-316]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InitInstance@CLianliankanApp@@UAEHXZ
  00051	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InitInstance@CLianliankanApp@@UAEHXZ ENDP		; CLianliankanApp::InitInstance
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ??0CLianliankanApp@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CLianliankanApp@@QAE@XZ PROC				; CLianliankanApp::CLianliankanApp, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	6a 00		 push	 0
  00009	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000c	e8 00 00 00 00	 call	 ??0CWinApp@@QAE@PB_W@Z	; CWinApp::CWinApp
  00011	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CLianliankanApp@@6B@

; 30   : 	// 支持重新启动管理器
; 31   : 	m_dwRestartManagerSupportFlags = AFX_RESTART_MANAGER_SUPPORT_RESTART;
; 32   : 
; 33   : 	// TODO: 在此处添加构造代码，
; 34   : 	// 将所有重要的初始化放置在 InitInstance 中
; 35   : }

  00017	8b c6		 mov	 eax, esi
  00019	c7 86 ac 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+172], 1
  00023	5e		 pop	 esi
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0CLianliankanApp@@QAE@XZ ENDP				; CLianliankanApp::CLianliankanApp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?GetApplicationRecoveryPingInterval@CWinApp@@UAEKXZ
_TEXT	SEGMENT
?GetApplicationRecoveryPingInterval@CWinApp@@UAEKXZ PROC ; CWinApp::GetApplicationRecoveryPingInterval, COMDAT
; _this$ = ecx

; 5365 : 	virtual DWORD GetApplicationRecoveryPingInterval() { return RECOVERY_DEFAULT_PING_INTERVAL; }  // Ping interval for RegisterApplicationRecoveryCallback

  00000	b8 88 13 00 00	 mov	 eax, 5000		; 00001388H
  00005	c3		 ret	 0
?GetApplicationRecoveryPingInterval@CWinApp@@UAEKXZ ENDP ; CWinApp::GetApplicationRecoveryPingInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?GetApplicationRecoveryParameter@CWinApp@@UAEPAXXZ
_TEXT	SEGMENT
?GetApplicationRecoveryParameter@CWinApp@@UAEPAXXZ PROC	; CWinApp::GetApplicationRecoveryParameter, COMDAT
; _this$ = ecx

; 5364 : 	virtual LPVOID GetApplicationRecoveryParameter() { return NULL; }  // Parameter to be passed along to RegisterApplicationRecoveryCallback

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?GetApplicationRecoveryParameter@CWinApp@@UAEPAXXZ ENDP	; CWinApp::GetApplicationRecoveryParameter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?GetApplicationRestartFlags@CWinApp@@UAEKXZ
_TEXT	SEGMENT
?GetApplicationRestartFlags@CWinApp@@UAEKXZ PROC	; CWinApp::GetApplicationRestartFlags, COMDAT
; _this$ = ecx

; 5363 : 	virtual DWORD GetApplicationRestartFlags() { return 0; }  // Flags for RegisterApplicationRestart: default is none of RESTART_NO_CRASH/RESTART_NO_HANG/RESTART_NO_PATCH/RESTART_NO_REBOOT

  00000	33 c0		 xor	 eax, eax
  00002	c3		 ret	 0
?GetApplicationRestartFlags@CWinApp@@UAEKXZ ENDP	; CWinApp::GetApplicationRestartFlags
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?RestoreAutosavedFilesAtRestart@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?RestoreAutosavedFilesAtRestart@CWinApp@@UBEHXZ PROC	; CWinApp::RestoreAutosavedFilesAtRestart, COMDAT
; _this$ = ecx

; 5361 : 	virtual BOOL RestoreAutosavedFilesAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 20	 and	 eax, 32			; 00000020H
  00009	c3		 ret	 0
?RestoreAutosavedFilesAtRestart@CWinApp@@UBEHXZ ENDP	; CWinApp::RestoreAutosavedFilesAtRestart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?ReopenPreviousFilesAtRestart@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?ReopenPreviousFilesAtRestart@CWinApp@@UBEHXZ PROC	; CWinApp::ReopenPreviousFilesAtRestart, COMDAT
; _this$ = ecx

; 5360 : 	virtual BOOL ReopenPreviousFilesAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 10	 and	 eax, 16			; 00000010H
  00009	c3		 ret	 0
?ReopenPreviousFilesAtRestart@CWinApp@@UBEHXZ ENDP	; CWinApp::ReopenPreviousFilesAtRestart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?SupportsAutosaveAtInterval@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?SupportsAutosaveAtInterval@CWinApp@@UBEHXZ PROC	; CWinApp::SupportsAutosaveAtInterval, COMDAT
; _this$ = ecx

; 5359 : 	virtual BOOL SupportsAutosaveAtInterval() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 08	 and	 eax, 8
  00009	c3		 ret	 0
?SupportsAutosaveAtInterval@CWinApp@@UBEHXZ ENDP	; CWinApp::SupportsAutosaveAtInterval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?SupportsAutosaveAtRestart@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?SupportsAutosaveAtRestart@CWinApp@@UBEHXZ PROC		; CWinApp::SupportsAutosaveAtRestart, COMDAT
; _this$ = ecx

; 5358 : 	virtual BOOL SupportsAutosaveAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 04	 and	 eax, 4
  00009	c3		 ret	 0
?SupportsAutosaveAtRestart@CWinApp@@UBEHXZ ENDP		; CWinApp::SupportsAutosaveAtRestart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?SupportsApplicationRecovery@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?SupportsApplicationRecovery@CWinApp@@UBEHXZ PROC	; CWinApp::SupportsApplicationRecovery, COMDAT
; _this$ = ecx

; 5357 : 	virtual BOOL SupportsApplicationRecovery() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_SUPPORT_RECOVERY; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 02	 and	 eax, 2
  00009	c3		 ret	 0
?SupportsApplicationRecovery@CWinApp@@UBEHXZ ENDP	; CWinApp::SupportsApplicationRecovery
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\afxwin.h
;	COMDAT ?SupportsRestartManager@CWinApp@@UBEHXZ
_TEXT	SEGMENT
?SupportsRestartManager@CWinApp@@UBEHXZ PROC		; CWinApp::SupportsRestartManager, COMDAT
; _this$ = ecx

; 5356 : 	virtual BOOL SupportsRestartManager() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_SUPPORT_RESTART; }

  00000	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00006	83 e0 01	 and	 eax, 1
  00009	c3		 ret	 0
?SupportsRestartManager@CWinApp@@UBEHXZ ENDP		; CWinApp::SupportsRestartManager
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 421  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b 7d 08	 mov	 edi, DWORD PTR _this$[ebp]

; 392  : 		m_dwLastError = GetLastError();

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0000e	8b f0		 mov	 esi, eax

; 422  : 		CPreserveLastError ple;
; 423  : 		va_list ptr; va_start(ptr, pszFmt);
; 424  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

  00010	8d 45 18	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  00013	50		 push	 eax
  00014	ff 75 14	 push	 DWORD PTR _pszFmt$[ebp]
  00017	ff 75 10	 push	 DWORD PTR _nLevel$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR _dwCategory$[ebp]
  0001d	ff 77 04	 push	 DWORD PTR [edi+4]
  00020	ff 37		 push	 DWORD PTR [edi]
  00022	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z ; ATL::CTrace::TraceV
  00027	83 c4 18	 add	 esp, 24			; 00000018H

; 397  : 		SetLastError(m_dwLastError);

  0002a	56		 push	 esi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi

; 425  : 		va_end(ptr);
; 426  : 	}

  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??RCTraceFileAndLineInfo@ATL@@QBAXHIPBDZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 411  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 410  : 		: m_pszFileName(pszFileName), m_nLineNo(nLineNo)

  00003	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b 45 0c	 mov	 eax, DWORD PTR _nLineNo$[ebp]
  0000b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 412  : 	}

  0000e	8b c1		 mov	 eax, ecx
  00010	5d		 pop	 ebp
  00011	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??1CPreserveLastError@ATL@@QAE@XZ
_TEXT	SEGMENT
??1CPreserveLastError@ATL@@QAE@XZ PROC			; ATL::CPreserveLastError::~CPreserveLastError, COMDAT
; _this$ = ecx

; 397  : 		SetLastError(m_dwLastError);

  00000	ff 31		 push	 DWORD PTR [ecx]
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetLastError@4

; 398  : 	}

  00008	c3		 ret	 0
??1CPreserveLastError@ATL@@QAE@XZ ENDP			; ATL::CPreserveLastError::~CPreserveLastError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CPreserveLastError@ATL@@QAE@XZ
_TEXT	SEGMENT
??0CPreserveLastError@ATL@@QAE@XZ PROC			; ATL::CPreserveLastError::CPreserveLastError, COMDAT
; _this$ = ecx

; 390  : 	CPreserveLastError()

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 391  : 	{
; 392  : 		m_dwLastError = GetLastError();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 393  : 	}

  0000b	8b c6		 mov	 eax, esi
  0000d	5e		 pop	 esi
  0000e	c3		 ret	 0
??0CPreserveLastError@ATL@@QAE@XZ ENDP			; ATL::CPreserveLastError::CPreserveLastError
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAEXI@Z PROC ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAEXI@Z ENDP ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::~CHeapPtr<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??1?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::~CHeapPtr<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	33 c0		 xor	 eax, eax
  00005	56		 push	 esi

; 470  : 	{

  00006	8b f1		 mov	 esi, ecx

; 152  : 	if(i64Result>UINT_MAX)

  00008	77 48		 ja	 SHORT $LN18@Allocate
  0000a	83 7d 08 ff	 cmp	 DWORD PTR _nElements$[ebp], -1
  0000e	77 42		 ja	 SHORT $LN18@Allocate

; 397  : 		ATLASSERT(m_pData == NULL);

  00010	39 06		 cmp	 DWORD PTR [esi], eax
  00012	74 26		 je	 SHORT $LN14@Allocate
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0001e	50		 push	 eax
  0001f	68 8d 01 00 00	 push	 397			; 0000018dH
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@
  00029	6a 02		 push	 2
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00031	83 c4 18	 add	 esp, 24			; 00000018H
  00034	83 f8 01	 cmp	 eax, 1
  00037	75 01		 jne	 SHORT $LN14@Allocate
  00039	cc		 int	 3
$LN14@Allocate:

; 277  : 		return malloc(nBytes);

  0003a	ff 75 08	 push	 DWORD PTR _nElements$[ebp]
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00043	83 c4 04	 add	 esp, 4

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  00046	89 06		 mov	 DWORD PTR [esi], eax
  00048	85 c0		 test	 eax, eax
  0004a	0f 95 c0	 setne	 al
  0004d	5e		 pop	 esi

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);
; 477  : 	}

  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
$LN18@Allocate:

; 471  : 		size_t nBytes=0;
; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))
; 473  : 		{
; 474  : 			return false;

  00052	32 c0		 xor	 al, al
  00054	5e		 pop	 esi

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);
; 477  : 	}

  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
?Allocate@?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<char,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 350  : 		m_pData(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 450  : 	{
; 451  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CHeapPtr@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<char,ATL::CCRTAllocator>::CHeapPtr<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 423  : 		Allocator::Free(m_pData);
; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 425  : 	}

  00015	c3		 ret	 0
?Free@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 397  : 		ATLASSERT(m_pData == NULL);

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 27		 je	 SHORT $LN4@AllocateBy
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00015	6a 00		 push	 0
  00017	68 8d 01 00 00	 push	 397			; 0000018dH
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@
  00021	6a 02		 push	 2
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00029	83 c4 18	 add	 esp, 24			; 00000018H
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	75 01		 jne	 SHORT $LN4@AllocateBy
  00031	cc		 int	 3
$LN4@AllocateBy:

; 277  : 		return malloc(nBytes);

  00032	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0003e	89 06		 mov	 DWORD PTR [esi], eax

; 399  : 		if (m_pData == NULL)

  00040	85 c0		 test	 eax, eax
  00042	0f 95 c0	 setne	 al
  00045	5e		 pop	 esi

; 400  : 			return false;
; 401  : 
; 402  : 		return true;
; 403  : 	}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ
_TEXT	SEGMENT
??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *, COMDAT
; _this$ = ecx

; 379  : 		return m_pData;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QBEPADXZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 365  : 		Free();
; 366  : 	}

  00015	c3		 ret	 0
??1?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::~CHeapPtrBase<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 350  : 		m_pData(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 352  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CHeapPtrBase@DVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<char,ATL::CCRTAllocator>::CHeapPtrBase<char,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	ff 75 08	 push	 DWORD PTR _classSize$[ebp]
  00006	6a 00		 push	 0
  00008	51		 push	 ecx
  00009	e8 00 00 00 00	 call	 _memset
  0000e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi
  00015	c3		 ret	 0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00006	56		 push	 esi

; 470  : 	{

  00007	8b f1		 mov	 esi, ecx

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00009	b9 02 00 00 00	 mov	 ecx, 2
  0000e	f7 e1		 mul	 ecx
  00010	57		 push	 edi
  00011	8b f8		 mov	 edi, eax

; 152  : 	if(i64Result>UINT_MAX)

  00013	85 d2		 test	 edx, edx
  00015	75 45		 jne	 SHORT $LN18@Allocate
  00017	83 ff ff	 cmp	 edi, -1
  0001a	77 40		 ja	 SHORT $LN18@Allocate

; 397  : 		ATLASSERT(m_pData == NULL);

  0001c	39 16		 cmp	 DWORD PTR [esi], edx
  0001e	74 25		 je	 SHORT $LN14@Allocate
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0002a	52		 push	 edx
  0002b	68 8d 01 00 00	 push	 397			; 0000018dH
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@
  00035	51		 push	 ecx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0003c	83 c4 18	 add	 esp, 24			; 00000018H
  0003f	83 f8 01	 cmp	 eax, 1
  00042	75 01		 jne	 SHORT $LN14@Allocate
  00044	cc		 int	 3
$LN14@Allocate:

; 277  : 		return malloc(nBytes);

  00045	57		 push	 edi
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0004c	83 c4 04	 add	 esp, 4

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0004f	89 06		 mov	 DWORD PTR [esi], eax
  00051	85 c0		 test	 eax, eax
  00053	0f 95 c0	 setne	 al
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);
; 477  : 	}

  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
$LN18@Allocate:
  0005c	5f		 pop	 edi

; 471  : 		size_t nBytes=0;
; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))
; 473  : 		{
; 474  : 			return false;

  0005d	32 c0		 xor	 al, al
  0005f	5e		 pop	 esi

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);
; 477  : 	}

  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 350  : 		m_pData(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 450  : 	{
; 451  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 423  : 		Allocator::Free(m_pData);
; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 425  : 	}

  00015	c3		 ret	 0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 397  : 		ATLASSERT(m_pData == NULL);

  00006	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00009	74 27		 je	 SHORT $LN4@AllocateBy
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00015	6a 00		 push	 0
  00017	68 8d 01 00 00	 push	 397			; 0000018dH
  0001c	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@IBEBMCEG@?$AAd?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AAe?$AAl?$AAo?$AAp?$AAe?$AAr?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt?$AA?5?$AAv?$AAi?$AAs?$AAu?$AAa?$AAl?$AA?5?$AAs?$AAt@
  00021	6a 02		 push	 2
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00029	83 c4 18	 add	 esp, 24			; 00000018H
  0002c	83 f8 01	 cmp	 eax, 1
  0002f	75 01		 jne	 SHORT $LN4@AllocateBy
  00031	cc		 int	 3
$LN4@AllocateBy:

; 277  : 		return malloc(nBytes);

  00032	ff 75 08	 push	 DWORD PTR _nBytes$[ebp]
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0003e	89 06		 mov	 DWORD PTR [esi], eax

; 399  : 		if (m_pData == NULL)

  00040	85 c0		 test	 eax, eax
  00042	0f 95 c0	 setne	 al
  00045	5e		 pop	 esi

; 400  : 			return false;
; 401  : 
; 402  : 		return true;
; 403  : 	}

  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 379  : 		return m_pData;

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 380  : 	}

  00002	c3		 ret	 0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 282  : 		free(p);

  00003	ff 36		 push	 DWORD PTR [esi]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0000b	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 365  : 		Free();
; 366  : 	}

  00015	c3		 ret	 0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 350  : 		m_pData(NULL)

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 352  : 	}

  00006	8b c1		 mov	 eax, ecx
  00008	c3		 ret	 0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z
_TEXT	SEGMENT
tv399 = -4						; size = 4
_wszBuf$ = -4						; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 238  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1655 :     int const _Result = __stdio_common_vsprintf(

  00005	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0000a	ff 75 1c	 push	 DWORD PTR _args$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR tv399[ebp], eax
  00010	6a 00		 push	 0
  00012	ff 75 18	 push	 DWORD PTR _pszFmt$[ebp]
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	6a 00		 push	 0
  00019	6a 00		 push	 0
  0001b	ff 70 04	 push	 DWORD PTR [eax+4]
  0001e	83 c9 02	 or	 ecx, 2
  00021	51		 push	 ecx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf
  00028	8b f0		 mov	 esi, eax
  0002a	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;

  0002d	83 c8 ff	 or	 eax, -1
  00030	85 f6		 test	 esi, esi
  00032	0f 48 f0	 cmovs	 esi, eax
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 240  : 		if (cchNeeded < 0)

  00035	85 f6		 test	 esi, esi
  00037	0f 88 af 00 00
	00		 js	 $LN128@TraceV
  0003d	53		 push	 ebx
  0003e	57		 push	 edi
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 350  : 		m_pData(NULL)

  0003f	33 ff		 xor	 edi, edi
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 246  : 		if (!szBuf.Allocate(cchNeeded + 1))

  00041	8d 5e 01	 lea	 ebx, DWORD PTR [esi+1]
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00044	33 c0		 xor	 eax, eax

; 152  : 	if(i64Result>UINT_MAX)

  00046	0f 87 94 00 00
	00		 ja	 $LN119@TraceV
  0004c	72 09		 jb	 SHORT $LN138@TraceV
  0004e	83 fb ff	 cmp	 ebx, -1
  00051	0f 87 89 00 00
	00		 ja	 $LN119@TraceV
$LN138@TraceV:

; 277  : 		return malloc(nBytes);

  00057	53		 push	 ebx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0005e	8b f8		 mov	 edi, eax

; 277  : 		return malloc(nBytes);

  00060	83 c4 04	 add	 esp, 4

; 399  : 		if (m_pData == NULL)

  00063	85 ff		 test	 edi, edi
  00065	74 79		 je	 SHORT $LN119@TraceV
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1581 :     int const _Result = __stdio_common_vsnprintf_s(

  00067	ff 75 1c	 push	 DWORD PTR _args$[ebp]
  0006a	8b 45 fc	 mov	 eax, DWORD PTR tv399[ebp]
  0006d	6a 00		 push	 0
  0006f	ff 75 18	 push	 DWORD PTR _pszFmt$[ebp]
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 251  : 		szBuf[0] = '\0';

  00072	c6 07 00	 mov	 BYTE PTR [edi], 0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1581 :     int const _Result = __stdio_common_vsnprintf_s(

  00075	56		 push	 esi
  00076	53		 push	 ebx
  00077	57		 push	 edi
  00078	ff 70 04	 push	 DWORD PTR [eax+4]
  0007b	ff 30		 push	 DWORD PTR [eax]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsnprintf_s
  00083	83 c4 20	 add	 esp, 32			; 00000020H

; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;

  00086	b9 ff ff ff ff	 mov	 ecx, -1
  0008b	85 c0		 test	 eax, eax
  0008d	0f 48 c1	 cmovs	 eax, ecx
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 253  : 		if (_vsnprintf_s(szBuf, cchNeeded + 1, cchNeeded, pszFmt, args) == -1)

  00090	3b c1		 cmp	 eax, ecx
  00092	74 4c		 je	 SHORT $LN119@TraceV

; 259  : 		if (!wszBuf.Allocate(cchNeeded + 1))

  00094	53		 push	 ebx
  00095	8d 4d fc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 350  : 		m_pData(NULL)

  00098	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _wszBuf$[ebp], 0
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 259  : 		if (!wszBuf.Allocate(cchNeeded + 1))

  0009f	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  000a4	8b 75 fc	 mov	 esi, DWORD PTR _wszBuf$[ebp]
  000a7	84 c0		 test	 al, al
  000a9	74 2b		 je	 SHORT $LN13@TraceV

; 260  : 		{
; 261  : 			return;
; 262  : 		}
; 263  : 
; 264  : 		wszBuf[0] = '\0';
; 265  : 
; 266  : 		if (::MultiByteToWideChar(CP_ACP, 0, szBuf, -1, wszBuf, cchNeeded + 1) == 0)

  000ab	53		 push	 ebx
  000ac	56		 push	 esi
  000ad	6a ff		 push	 -1
  000af	33 c0		 xor	 eax, eax
  000b1	57		 push	 edi
  000b2	50		 push	 eax
  000b3	50		 push	 eax
  000b4	66 89 06	 mov	 WORD PTR [esi], ax
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  000bd	85 c0		 test	 eax, eax
  000bf	74 15		 je	 SHORT $LN13@TraceV

; 267  : 		{
; 268  : 			return;
; 269  : 		}
; 270  : 
; 271  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

  000c1	56		 push	 esi
  000c2	ff 75 14	 push	 DWORD PTR _nLevel$[ebp]
  000c5	ff 75 10	 push	 DWORD PTR _dwCategory$[ebp]
  000c8	ff 75 0c	 push	 DWORD PTR _nLine$[ebp]
  000cb	ff 75 08	 push	 DWORD PTR _pszFileName$[ebp]
  000ce	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ; ATL::CTrace::TraceV
  000d3	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@TraceV:
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 282  : 		free(p);

  000d6	56		 push	 esi
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000dd	83 c4 04	 add	 esp, 4
$LN119@TraceV:
  000e0	57		 push	 edi
  000e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000e7	83 c4 04	 add	 esp, 4
  000ea	5f		 pop	 edi
  000eb	5b		 pop	 ebx
$LN128@TraceV:
  000ec	5e		 pop	 esi
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 272  : 	}

  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c3		 ret	 0
?TraceV@CTrace@ATL@@SAXPBDHII0PAD@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_pszFileName$GSCopy$1$ = -2580				; size = 4
_wszBuf$ = -2576					; size = 4
_wszCategory$ = -2572					; size = 2048
_fileName$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 150  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 0a 00
	00		 sub	 esp, 2580		; 00000a14H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  00016	56		 push	 esi
  00017	8b 75 10	 mov	 esi, DWORD PTR _dwCategory$[ebp]
  0001a	89 85 ec f5 ff
	ff		 mov	 DWORD PTR _pszFileName$GSCopy$1$[ebp], eax

; 151  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
  00025	57		 push	 edi
  00026	8b 7d 18	 mov	 edi, DWORD PTR _pwszMessage$[ebp]
  00029	83 f8 ff	 cmp	 eax, -1
  0002c	0f 84 23 01 00
	00		 je	 $LN3@TraceV
  00032	3b 45 14	 cmp	 eax, DWORD PTR _nLevel$[ebp]
  00035	0f 82 1a 01 00
	00		 jb	 $LN3@TraceV
  0003b	85 35 00 00 00
	00		 test	 DWORD PTR ?m_nCategory@CTrace@ATL@@1IA, esi ; ATL::CTrace::m_nCategory
  00041	0f 84 0e 01 00
	00		 je	 $LN3@TraceV

; 152  : 		{
; 153  : 			return;
; 154  : 		}
; 155  : 
; 156  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};
; 157  : 		int categoryLength = 0;
; 158  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

  00047	68 00 08 00 00	 push	 2048			; 00000800H
  0004c	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp]
  00052	6a 00		 push	 0
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _memset
  0005a	56		 push	 esi
  0005b	e8 00 00 00 00	 call	 ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ; ATL::CTrace::GetCategoryName
  00060	83 c4 10	 add	 esp, 16			; 00000010H

; 159  : 		if (pwszCategoryName != nullptr)

  00063	85 c0		 test	 eax, eax
  00065	74 08		 je	 SHORT $LN4@TraceV

; 160  : 		{
; 161  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%ls - ", pwszCategoryName)) == -1)

  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_1O@LFNDFEBP@?$AA?$CF?$AAl?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@

; 162  : 			{
; 163  : 				return;
; 164  : 			}
; 165  : 		}
; 166  : 		else

  0006d	eb 06		 jmp	 SHORT $LN67@TraceV
$LN4@TraceV:

; 167  : 		{
; 168  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

  0006f	56		 push	 esi
  00070	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
$LN67@TraceV:
  00075	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp]
  0007b	68 00 04 00 00	 push	 1024			; 00000400H
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _swprintf_s
  00086	8b d0		 mov	 edx, eax
  00088	83 c4 10	 add	 esp, 16			; 00000010H
  0008b	83 fa ff	 cmp	 edx, -1
  0008e	0f 84 c1 00 00
	00		 je	 $LN3@TraceV

; 174  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

  00094	8b cf		 mov	 ecx, edi
  00096	8d 71 02	 lea	 esi, DWORD PTR [ecx+2]
  00099	0f 1f 80 00 00
	00 00		 npad	 7
$LL65@TraceV:
  000a0	66 8b 01	 mov	 ax, WORD PTR [ecx]
  000a3	83 c1 02	 add	 ecx, 2
  000a6	66 85 c0	 test	 ax, ax
  000a9	75 f5		 jne	 SHORT $LL65@TraceV
  000ab	53		 push	 ebx
  000ac	2b ce		 sub	 ecx, esi
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 350  : 		m_pData(NULL)

  000ae	c7 85 f0 f5 ff
	ff 00 00 00 00	 mov	 DWORD PTR _wszBuf$[ebp], 0
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 174  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

  000b8	d1 f9		 sar	 ecx, 1
  000ba	8d 5a 01	 lea	 ebx, DWORD PTR [edx+1]
  000bd	03 d9		 add	 ebx, ecx

; 175  : 		CHeapPtr<wchar_t> wszBuf;
; 176  : 		if (!wszBuf.Allocate(chCount))

  000bf	8d 8d f0 f5 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000c5	53		 push	 ebx
  000c6	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  000cb	8b b5 f0 f5 ff
	ff		 mov	 esi, DWORD PTR _wszBuf$[ebp]
  000d1	84 c0		 test	 al, al
  000d3	74 75		 je	 SHORT $LN15@TraceV

; 177  : 		{
; 178  : 			return;
; 179  : 		}
; 180  : 
; 181  : 		wszBuf[0] = '\0';

  000d5	33 c0		 xor	 eax, eax

; 182  : 
; 183  : 		if (swprintf_s(wszBuf, chCount, L"%ls%ls", wszCategory, pwszMessage) == -1)

  000d7	57		 push	 edi
  000d8	66 89 06	 mov	 WORD PTR [esi], ax
  000db	8d 85 f4 f5 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp]
  000e1	50		 push	 eax
  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_1O@OAIPCDPO@?$AA?$CF?$AAl?$AAs?$AA?$CF?$AAl?$AAs?$AA?$AA@
  000e7	53		 push	 ebx
  000e8	56		 push	 esi
  000e9	e8 00 00 00 00	 call	 _swprintf_s
  000ee	83 c4 14	 add	 esp, 20			; 00000014H
  000f1	83 f8 ff	 cmp	 eax, -1
  000f4	74 54		 je	 SHORT $LN15@TraceV

; 184  : 		{
; 185  : 			return;
; 186  : 		}
; 187  : 
; 188  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	
; 189  : #if _MSC_VER < 1900
; 190  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)
; 191  : #else
; 192  : 		if (swprintf_s(fileName, _MAX_PATH, L"%hs", pszFileName) == -1)

  000f6	68 08 02 00 00	 push	 520			; 00000208H
  000fb	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00101	6a 00		 push	 0
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _memset
  00109	ff b5 ec f5 ff
	ff		 push	 DWORD PTR _pszFileName$GSCopy$1$[ebp]
  0010f	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00115	68 00 00 00 00	 push	 OFFSET ??_C@_17LGGGMOOB@?$AA?$CF?$AAh?$AAs?$AA?$AA@
  0011a	68 04 01 00 00	 push	 260			; 00000104H
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _swprintf_s
  00125	83 c4 1c	 add	 esp, 28			; 0000001cH
  00128	83 f8 ff	 cmp	 eax, -1
  0012b	74 1d		 je	 SHORT $LN15@TraceV

; 193  : #endif
; 194  : 		{
; 195  : 			return;
; 196  : 		}
; 197  : 
; 198  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%ls", static_cast<const wchar_t*>(wszBuf));

  0012d	56		 push	 esi
  0012e	68 00 00 00 00	 push	 OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00133	6a 00		 push	 0
  00135	ff 75 0c	 push	 DWORD PTR _nLine$[ebp]
  00138	8d 85 f4 fd ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  0013e	50		 push	 eax
  0013f	6a 00		 push	 0
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00147	83 c4 18	 add	 esp, 24			; 00000018H
$LN15@TraceV:
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h

; 282  : 		free(p);

  0014a	56		 push	 esi
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00151	83 c4 04	 add	 esp, 4
  00154	5b		 pop	 ebx
$LN3@TraceV:
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h

; 199  : 	}

  00155	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00158	5f		 pop	 edi
  00159	33 cd		 xor	 ecx, ebp
  0015b	5e		 pop	 esi
  0015c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 132  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 133  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  00009	33 c0		 xor	 eax, eax
  0000b	56		 push	 esi
  0000c	85 d2		 test	 edx, edx
  0000e	74 17		 je	 SHORT $LN3@GetCategor
  00010	8b 75 08	 mov	 esi, DWORD PTR _nCategory$[ebp]
  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A ; ATL::CTrace::m_nMap
$LL4@GetCategor:

; 134  : 		{
; 135  : 			if (m_nMap[i].nCategory == nCategory)

  00018	39 31		 cmp	 DWORD PTR [ecx], esi
  0001a	74 10		 je	 SHORT $LN8@GetCategor

; 133  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

  0001c	40		 inc	 eax
  0001d	81 c1 04 01 00
	00		 add	 ecx, 260		; 00000104H
  00023	3b c2		 cmp	 eax, edx
  00025	72 f1		 jb	 SHORT $LL4@GetCategor
$LN3@GetCategor:

; 138  : 			}
; 139  : 		}
; 140  : 
; 141  : 		return nullptr;

  00027	33 c0		 xor	 eax, eax
  00029	5e		 pop	 esi

; 142  : 	}

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
$LN8@GetCategor:

; 136  : 			{
; 137  : 				return m_nMap[i].categryName;

  0002c	69 c0 04 01 00
	00		 imul	 eax, eax, 260
  00032	5e		 pop	 esi
  00033	05 04 00 00 00	 add	 eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4

; 142  : 	}

  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
??B?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<524288,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 80   : #ifdef _DEBUG
; 81   : 		return traceCategory;

  00000	b8 00 00 08 00	 mov	 eax, 524288		; 00080000H

; 82   : #else
; 83   : 		return 0;
; 84   : #endif
; 85   : 	}

  00005	c3		 ret	 0
??B?$CTraceCategoryEx@$0IAAAA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<524288,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 282  : 		free(p);

  00000	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__free
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  : 	}

  00003	5d		 pop	 ebp

; 277  : 		return malloc(nBytes);

  00004	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__malloc
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00006	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]

; 152  : 	if(i64Result>UINT_MAX)

  00009	85 d2		 test	 edx, edx
  0000b	75 0e		 jne	 SHORT $LN8@AtlMultipl
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	77 09		 ja	 SHORT $LN8@AtlMultipl

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  00012	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  00015	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  00017	33 c0		 xor	 eax, eax

; 158  : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN8@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  0001b	b8 16 02 07 80	 mov	 eax, -2147024362	; 80070216H

; 158  : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vscprintf
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__ArgList$ = 12						; size = 4
__vscprintf PROC					; COMDAT

; 1671 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 0c	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 08	 push	 DWORD PTR __Format$[ebp]
  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	8b 08		 mov	 ecx, DWORD PTR [eax]
  00016	ff 70 04	 push	 DWORD PTR [eax+4]
  00019	83 c9 02	 or	 ecx, 2
  0001c	51		 push	 ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1672 :     return _vscprintf_l(_Format, NULL, _ArgList);
; 1673 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
__vscprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vscprintf_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$ = 12						; size = 4
__ArgList$ = 16						; size = 4
__vscprintf_l PROC					; COMDAT

; 1654 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1655 :     int const _Result = __stdio_common_vsprintf(

  00003	ff 75 10	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __Format$[ebp]
  0000c	6a 00		 push	 0
  0000e	6a 00		 push	 0
  00010	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	83 c9 02	 or	 ecx, 2
  0001d	51		 push	 ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsprintf

; 1656 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1657 :         NULL, 0, _Format, _Locale, _ArgList);
; 1658 : 
; 1659 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1660 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vscprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__MaxCount$ = 16					; size = 4
__Format$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_s PROC					; COMDAT

; 1601 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1581 :     int const _Result = __stdio_common_vsnprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	6a 00		 push	 0
  00008	ff 75 14	 push	 DWORD PTR __Format$[ebp]
  0000b	ff 75 10	 push	 DWORD PTR __MaxCount$[ebp]
  0000e	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  00011	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsnprintf_s

; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 20	 add	 esp, 32			; 00000020H
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1602 :     return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);
; 1603 : }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
__vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__MaxCount$ = 16					; size = 4
__Format$ = 20						; size = 4
__Locale$ = 24						; size = 4
__ArgList$ = 28						; size = 4
__vsnprintf_s_l PROC					; COMDAT

; 1580 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1581 :     int const _Result = __stdio_common_vsnprintf_s(

  00003	ff 75 1c	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 18	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 14	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 10	 push	 DWORD PTR __MaxCount$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  00012	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00015	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001a	ff 70 04	 push	 DWORD PTR [eax+4]
  0001d	ff 30		 push	 DWORD PTR [eax]
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vsnprintf_s

; 1582 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1583 :         _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1584 : 
; 1585 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 20	 add	 esp, 32			; 00000020H
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1586 : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT _swprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_swprintf_s PROC					; COMDAT

; 1536 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Buffer$[ebp]

; 1263 :     int const _Result = __stdio_common_vswprintf_s(

  00006	8d 4d 14	 lea	 ecx, DWORD PTR __Format$[ebp+4]
  00009	51		 push	 ecx
  0000a	6a 00		 push	 0
  0000c	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000f	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	ff 30		 push	 DWORD PTR [eax]
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s

; 1264 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1265 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1266 : 
; 1267 :     return _Result < 0 ? -1 : _Result;

  00023	83 c9 ff	 or	 ecx, -1
  00026	83 c4 1c	 add	 esp, 28			; 0000001cH
  00029	85 c0		 test	 eax, eax
  0002b	0f 48 c1	 cmovs	 eax, ecx

; 1537 :         int _Result;
; 1538 :         va_list _ArgList;
; 1539 :         __crt_va_start(_ArgList, _Format);
; 1540 :         _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1541 :         __crt_va_end(_ArgList);
; 1542 :         return _Result;
; 1543 :     }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
_swprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_wstdio.h
;	COMDAT __vswprintf_s_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vswprintf_s_l PROC					; COMDAT

; 1262 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1263 :     int const _Result = __stdio_common_vswprintf_s(

  00003	ff 75 18	 push	 DWORD PTR __ArgList$[ebp]
  00006	ff 75 14	 push	 DWORD PTR __Locale$[ebp]
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	ff 70 04	 push	 DWORD PTR [eax+4]
  0001a	ff 30		 push	 DWORD PTR [eax]
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vswprintf_s

; 1264 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1265 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1266 : 
; 1267 :     return _Result < 0 ? -1 : _Result;

  00022	83 c9 ff	 or	 ecx, -1
  00025	83 c4 1c	 add	 esp, 28			; 0000001cH
  00028	85 c0		 test	 eax, eax
  0002a	0f 48 c1	 cmovs	 eax, ecx

; 1268 : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
__vswprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\developer\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ PROC ; __vcrt_va_start_verify_argument_type<wchar_t const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QB_W@@YAXXZ ENDP ; __vcrt_va_start_verify_argument_type<wchar_t const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	7e 08		 jle	 SHORT $LN4@HRESULT_FR
  0000a	0f b7 c0	 movzx	 eax, ax
  0000d	0d 00 00 07 80	 or	 eax, -2147024896	; 80070000H
$LN4@HRESULT_FR:
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File d:\study\数据结构与算法综合实验\连连看游戏\llkpro17.6.18\lianliankan\lianliankan.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
